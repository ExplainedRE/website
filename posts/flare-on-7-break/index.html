<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="robots" content="noodp" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
        <title>Flare-On 7 — 10 Break - explained.re</title><meta name="Description" content=""><meta property="og:title" content="Flare-On 7 — 10 Break" />
<meta property="og:description" content="Challenge Description  As a reward for making it this far in Flare-On, we&rsquo;ve decided to give you a break. Welcome to the land of sunshine and rainbows!   For your convenience, use the table of contents on the sidebar to navigate to different locations and skip parts that you are rather familiar with.
Initial Analysis First Look at ./break Looks like this challenge author decided to give us a break after all that hard work we&rsquo;ve done so far." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://explained.re/posts/flare-on-7-break/" />
<meta property="og:image" content="https://explained.re/images/explained_dark.png"/>
<meta property="article:published_time" content="2020-10-23T21:29:50+03:00" />
<meta property="article:modified_time" content="2020-10-23T21:29:50+03:00" />
<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://explained.re/images/explained_dark.png"/>

<meta name="twitter:title" content="Flare-On 7 — 10 Break"/>
<meta name="twitter:description" content="Challenge Description  As a reward for making it this far in Flare-On, we&rsquo;ve decided to give you a break. Welcome to the land of sunshine and rainbows!   For your convenience, use the table of contents on the sidebar to navigate to different locations and skip parts that you are rather familiar with.
Initial Analysis First Look at ./break Looks like this challenge author decided to give us a break after all that hard work we&rsquo;ve done so far."/>
<meta name="application-name" content="explained.re">
<meta name="apple-mobile-web-app-title" content="explained.re"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
        <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="manifest" href="/site.webmanifest"><link rel="canonical" href="https://explained.re/posts/flare-on-7-break/" /><link rel="prev" href="https://explained.re/posts/flare-on7-crackinstaller/" /><link rel="next" href="https://explained.re/posts/flare-on-7-rabbithole/" /><link rel="stylesheet" href="/lib/normalize/normalize.min.css"><link rel="stylesheet" href="/css/style.min.css"><link rel="stylesheet" href="/lib/fontawesome-free/all.min.css"><link rel="stylesheet" href="/lib/animate/animate.min.css"><script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "headline": "Flare-On 7 — 10 Break",
        "inLanguage": "en",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "https:\/\/explained.re\/posts\/flare-on-7-break\/"
        },"genre": "posts","keywords": "flare-on","wordcount":  13229 ,
        "url": "https:\/\/explained.re\/posts\/flare-on-7-break\/","datePublished": "2020-10-23T21:29:50+03:00","dateModified": "2020-10-23T21:29:50+03:00","publisher": {
            "@type": "Organization",
            "name": "explained.re"},"author": {
                "@type": "Person",
                "name": "explained.re"
            },"description": ""
    }
    </script></head>
    <body header-desktop="fixed" header-mobile="auto"><script type="text/javascript">(window.localStorage && localStorage.getItem('theme') ? localStorage.getItem('theme') === 'dark' : ('dark' === 'auto' ? window.matchMedia('(prefers-color-scheme: dark)').matches : 'dark' === 'dark')) && document.body.setAttribute('theme', 'dark');</script>

        <div id="mask"></div><div class="wrapper"><header class="desktop" id="header-desktop">
    <div class="header-wrapper">
        <div class="header-title">
            <a href="/" title="explained.re"><img
        class="lazyload logo"
        src="/svg/loading.min.svg"
        data-src="/images/explained.svg"
        data-srcset="/images/explained.svg, /images/explained.svg 1.5x, /images/explained.svg 2x"
        data-sizes="auto"
        alt="/images/explained.svg"
        title="/images/explained.svg" /></a>
        </div>
        <div class="menu">
            <div class="menu-inner"><a class="menu-item" href="/posts/"> Posts </a><a class="menu-item" href="/tags/"> Tags </a><a class="menu-item" href="/categories/"> Categories </a><a class="menu-item" href="/about/"> About </a><a class="menu-item" href="https://github.com/explainedre/website" title="GitHub" rel="noopener noreffer" target="_blank"><i class='fab fa-github fa-fw'></i>  </a><span class="menu-item delimiter"></span><a href="javascript:void(0);" class="menu-item theme-switch" title="Switch Theme">
                    <i class="fas fa-adjust fa-fw"></i>
                </a>
            </div>
        </div>
    </div>
</header><header class="mobile" id="header-mobile">
    <div class="header-container">
        <div class="header-wrapper">
            <div class="header-title">
                <a href="/" title="explained.re"><img
        class="lazyload logo"
        src="/svg/loading.min.svg"
        data-src="/images/explained.svg"
        data-srcset="/images/explained.svg, /images/explained.svg 1.5x, /images/explained.svg 2x"
        data-sizes="auto"
        alt="/images/explained.svg"
        title="/images/explained.svg" /></a>
            </div>
            <div class="menu-toggle" id="menu-toggle-mobile">
                <span></span><span></span><span></span>
            </div>
        </div>
        <div class="menu" id="menu-mobile"><a class="menu-item" href="/posts/" title="">Posts</a><a class="menu-item" href="/tags/" title="">Tags</a><a class="menu-item" href="/categories/" title="">Categories</a><a class="menu-item" href="/about/" title="">About</a><a class="menu-item" href="https://github.com/explainedre/website" title="GitHub" rel="noopener noreffer" target="_blank"><i class='fab fa-github fa-fw'></i></a><a href="javascript:void(0);" class="menu-item theme-switch" title="Switch Theme">
                <i class="fas fa-adjust fa-fw"></i>
            </a></div>
    </div>
</header>
<div class="search-dropdown desktop">
    <div id="search-dropdown-desktop"></div>
</div>
<div class="search-dropdown mobile">
    <div id="search-dropdown-mobile"></div>
</div>
<main class="main">
                <div class="container"><div class="toc" id="toc-auto">
            <h2 class="toc-title">Contents</h2>
            <div class="toc-content" id="toc-content-auto"></div>
        </div><article class="page single"><h1 class="single-title animated flipInX">Flare-On 7 — 10 Break</h1><div class="post-meta">
            <div class="post-meta-line"><span class="post-author"><a href="/" title="Author" rel=" author" class="author"><i class="fas fa-user-circle fa-fw"></i>explained.re</a></span>&nbsp;<span class="post-category">included in <a href="/categories/write-up/"><i class="far fa-folder fa-fw"></i>write-up</a>&nbsp;<a href="/categories/ctf/"><i class="far fa-folder fa-fw"></i>ctf</a></span></div>
            <div class="post-meta-line"><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime="2020-10-23">2020-10-23</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;13229 words&nbsp;
                <i class="far fa-clock fa-fw"></i>&nbsp;63 minutes&nbsp;</div>
        </div><div class="details toc" id="toc-static"  kept="">
                <div class="details-summary toc-title">
                    <span>Contents</span>
                    <span><i class="details-icon fas fa-angle-right"></i></span>
                </div>
                <div class="details-content toc-content" id="toc-content-static"><nav id="TableOfContents">
  <ul>
    <li><a href="#first-look-at-break">First Look at ./<em>break</em></a></li>
    <li><a href="#initialization-code">Initialization Code</a></li>
    <li><a href="#understanding-fork">Understanding fork</a></li>
    <li><a href="#child1-analysis">Child1 Analysis</a></li>
  </ul>

  <ul>
    <li><a href="#understanding-syscall-emulation">Understanding Syscall Emulation</a></li>
    <li><a href="#string-encryption">String Encryption</a></li>
    <li><a href="#analyzing-child2">Analyzing <em>child2</em></a></li>
    <li><a href="#getting-rid-of-the-child2">Getting Rid of the <em>child2</em></a>
      <ul>
        <li><a href="#theory">Theory</a></li>
        <li><a href="#classic-patching"><strong>Classic Patching</strong></a></li>
        <li><a href="#emulation"><strong>Emulation</strong></a></li>
        <li><a href="#overcoming-fork">Overcoming Fork</a></li>
        <li><a href="#patching-child1">Patching <em>child1</em></a></li>
      </ul>
    </li>
    <li><a href="#decrypting-the-strings">Decrypting the Strings</a></li>
    <li><a href="#understanding-the-first-check">Understanding the First Check</a></li>
    <li><a href="#patching-memcmp">Patching <em>memcmp</em></a></li>
  </ul>

  <ul>
    <li><a href="#analyzing-the-second-check">Analyzing the Second Check</a>
      <ul>
        <li><a href="#understanding-nice">Understanding <em>nice</em></a></li>
        <li><a href="#understanding-truncate">Understanding <em>truncate</em></a></li>
      </ul>
    </li>
    <li><a href="#understanding-the-second-check">Understanding the Second Check</a>
      <ul>
        <li><a href="#debugging-method">Debugging Method</a></li>
        <li><a href="#hooking-method">Hooking Method</a></li>
        <li><a href="#calculating-the-2nd-part-of-the-flag">Calculating the 2nd part of the flag</a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li><a href="#getting-to-the-third-check">Getting to the Third Check</a></li>
    <li><a href="#analyzing-the-shellcode">Analyzing the Shellcode</a>
      <ul>
        <li><a href="#reversing-the-process">Reversing the Process</a></li>
      </ul>
    </li>
  </ul>
</nav></div>
            </div><div class="content" id="content"><div class="details admonition info open">
        <div class="details-summary admonition-title">
            <i class="icon fas fa-info-circle fa-fw"></i>Challenge Description<i class="details-icon fas fa-angle-right fa-fw"></i>
        </div>
        <div class="details-content">
            <div class="admonition-content">As a reward for making it this far in Flare-On, we&rsquo;ve decided to give you a break. Welcome to the land of sunshine and rainbows!</div>
        </div>
    </div>
<p><em>For your convenience, use the table of contents on the sidebar to navigate to different locations and skip parts that you are rather familiar with.</em></p>
<h1 id="initial-analysis">Initial Analysis</h1>
<h2 id="first-look-at-break">First Look at ./<em>break</em></h2>
<p>Looks like this challenge author decided to give us a break after all that hard work we&rsquo;ve done so far. Neat!
Jokes aside, this looks like the first troll out of many others this challenge authors created in this one. Anyway, let&rsquo;s dig in.</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ file <span class="nb">break</span>
break: ELF 32-bit LSB executable, Intel 80386, version <span class="m">1</span> <span class="o">(</span>SYSV<span class="o">)</span>, dynamically linked, interpreter /lib/ld-linux.so.2, <span class="k">for</span> GNU/Linux 2.6.32, BuildID<span class="o">[</span>sha1<span class="o">]=</span>1793c43108b544ef35f9814b0caafcf76210631c, stripped

$ ./break
welcome to the land of sunshine and rainbows!
as a reward <span class="k">for</span> getting this far in FLARE-ON, we<span class="s1">&#39;ve decided to make this one soooper easy
</span><span class="s1">
</span><span class="s1">please enter a password friend :) AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
</span><span class="s1">sorry, but &#39;</span>sorry i stole your input :<span class="o">)</span><span class="err">&#39;</span> is not correct
</code></pre></div><p>This one seems to be a stripped 32 bit ELF executable, and once it&rsquo;s executed it simply requests for the password, probably performs some checks, and finally spits out whether the password is correct or not.</p>
<p>Notice that it says that <code>'sorry i stole your input :)'</code> is not the correct password, even though we inserted a bunch of As. This is odd, and we should keep this in mind while analyzing this sample.</p>
<p>Opening the binary in our disassembler of choice, we can see a pretty straight forward <code>main</code> function.</p>
<a class="lightgallery" href="/posts/flare-on-7-break/images/image.png" title="/posts/flare-on-7-break/images/image.png" data-thumbnail="/posts/flare-on-7-break/images/image.png">
        <img
            class="lazyload"
            src="/svg/loading.min.svg"
            data-src="images/image.png"
            data-srcset="/posts/flare-on-7-break/images/image.png, images/image.png 1.5x, /posts/flare-on-7-break/images/image.png 2x"
            data-sizes="auto"
            alt="/posts/flare-on-7-break/images/image.png" />
    </a>
<p>Looks like it prints out the welcome messages, then reads 255 bytes from <code>STDIN</code>, then passes the input buffer to a function at offset <code>08048CDB</code>, and based on the return value, it&rsquo;ll print the result. Seems easy. Too easy.</p>
<a class="lightgallery" href="/posts/flare-on-7-break/images/image_1.png" title="/posts/flare-on-7-break/images/image_1.png" data-thumbnail="/posts/flare-on-7-break/images/image_1.png">
        <img
            class="lazyload"
            src="/svg/loading.min.svg"
            data-src="images/image_1.png"
            data-srcset="/posts/flare-on-7-break/images/image_1.png, images/image_1.png 1.5x, /posts/flare-on-7-break/images/image_1.png 2x"
            data-sizes="auto"
            alt="/posts/flare-on-7-break/images/image_1.png" />
    </a>
<p>The input buffer seems to be compared with <a href="mailto:sunsh1n3_4nd_r41nb0ws@flare-on.com" rel=""><code>sunsh1n3_4nd_r41nb0ws@flare-on.com</code></a>. Did we just solve this?</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ ./break
welcome to the land of sunshine and rainbows!
as a reward <span class="k">for</span> getting this far in FLARE-ON, we<span class="s1">&#39;ve decided to make this one soooper easy
</span><span class="s1">
</span><span class="s1">please enter a password friend :) sunsh1n3_4nd_r41nb0ws@flare-on.com
</span><span class="s1">sorry, but &#39;</span>sorry i stole your input :<span class="o">)</span><span class="err">&#39;</span> is not correct
</code></pre></div><p>Quick execution of the binary with this input shows that we didn&rsquo;t, which makes quite a lot of sense since we&rsquo;re dealing with level 10 here. As you can see in the input above, we did get the exact same message like before, even though our input was different. Our assumption now should be that there is some more code in this binary that&rsquo;s executing besides what we see in the <code>main</code> function.</p>
<h2 id="initialization-code">Initialization Code</h2>
<p>If we think there&rsquo;s some more code running than what we see in <code>main</code>, and we can&rsquo;t debug the binary, a good place to start looking for more code being executed is the <a href="https://gcc.gnu.org/onlinedocs/gccint/Initialization.html" target="_blank" rel="noopener noreffer"><em>initialization routines</em></a>. These routines include different types of <em>constructors</em> used by the binary, and they are executed <strong>before</strong> the program&rsquo;s <code>main</code>.</p>
<p>We can find these functions by navigating to the entry point of the code, there we&rsquo;ll see a call to <a href="https://refspecs.linuxbase.org/LSB_3.1.0/LSB-generic/LSB-generic/baselib---libc-start-main-.html" target="_blank" rel="noopener noreffer">___libc_start_main</a>. This function&rsquo;s 4th parameter is a pointer to an <code>init</code> function, which is responsible for calling all the <em>initialization routines</em> the program contains. In our case, it&rsquo;s located in <code>08056320</code>.</p>
<a class="lightgallery" href="/posts/flare-on-7-break/images/image_2.png" title="/posts/flare-on-7-break/images/image_2.png" data-thumbnail="/posts/flare-on-7-break/images/image_2.png">
        <img
            class="lazyload"
            src="/svg/loading.min.svg"
            data-src="images/image_2.png"
            data-srcset="/posts/flare-on-7-break/images/image_2.png, images/image_2.png 1.5x, /posts/flare-on-7-break/images/image_2.png 2x"
            data-sizes="auto"
            alt="/posts/flare-on-7-break/images/image_2.png" />
    </a>
<p>In this <code>init</code> function, we can see a loop that iterates over an array containing <em>initialization routines</em> pointers and calling each one of them. The array (located in <code>081A4EFC</code>) contains 2 functions.</p>
<p>Skimming through those functions, our interest is piqued by the second one (<code>08048FC5</code>), which calls <code>fork</code> and exits the process if the call fails, which is not something you usually see in an initialization routine.</p>
<a class="lightgallery" href="/posts/flare-on-7-break/images/image_3.png" title="/posts/flare-on-7-break/images/image_3.png" data-thumbnail="/posts/flare-on-7-break/images/image_3.png">
        <img
            class="lazyload"
            src="/svg/loading.min.svg"
            data-src="images/image_3.png"
            data-srcset="/posts/flare-on-7-break/images/image_3.png, images/image_3.png 1.5x, /posts/flare-on-7-break/images/image_3.png 2x"
            data-sizes="auto"
            alt="/posts/flare-on-7-break/images/image_3.png" />
    </a>
<h2 id="understanding-fork">Understanding fork</h2>
<p><a href="https://man7.org/linux/man-pages/man2/fork.2.html" target="_blank" rel="noopener noreffer">fork</a> duplicates the calling process by creating a new one and copying all the memory to it from the first one, which means the new process will be executing the next instruction in this function as do the original calling process. The way to differentiate between the calling process and the newly created one is by looking at the return code of <code>fork</code>. In the original calling process, the return value will be the PID of the new child process. In this case, the program will branch and call <a href="https://man7.org/linux/man-pages/man2/prctl.2.html" target="_blank" rel="noopener noreffer">prctl</a> with the option <code>0x59616d61</code> and the PID of the newly forked process. A quick google search for &ldquo;prctl 0x59616d61&rdquo; will reveal that this option is <code>PR_SET_PTRACER</code> and it means that the process sets its ptracer to be the new child process. This explains why we couldn&rsquo;t connect a debugger to the binary - it already had a ptracer and a process in Linux can only have one at any given time. At this point, the original process (will be referred to as the parent process from now on) will sleep before continuing to execute, giving a chance to the child process to start its logic.</p>
<h2 id="child1-analysis">Child1 Analysis</h2>
<p>In the newly forked process, the return value of <code>fork</code> will be <code>0</code>. In this case, the program will not branch and will continue to execute the function at <code>080490C4</code>, passing the <em>parent</em> PID as a parameter to it.</p>
<a class="lightgallery" href="/posts/flare-on-7-break/images/image_4.png" title="/posts/flare-on-7-break/images/image_4.png" data-thumbnail="/posts/flare-on-7-break/images/image_4.png">
        <img
            class="lazyload"
            src="/svg/loading.min.svg"
            data-src="images/image_4.png"
            data-srcset="/posts/flare-on-7-break/images/image_4.png, images/image_4.png 1.5x, /posts/flare-on-7-break/images/image_4.png 2x"
            data-sizes="auto"
            alt="/posts/flare-on-7-break/images/image_4.png" />
    </a>
<p>We&rsquo;ll refer to this newly forked process as <em>child1</em> from now on. The function at <code>0x080490C4</code> contains quite a lot of code, so let&rsquo;s dig into that.</p>
<p>The first thing we notice, is that there are a lot of calls to a function at <code>0x0804BAE6</code>.</p>
<a class="lightgallery" href="/posts/flare-on-7-break/images/image_5.png" title="/posts/flare-on-7-break/images/image_5.png" data-thumbnail="/posts/flare-on-7-break/images/image_5.png">
        <img
            class="lazyload"
            src="/svg/loading.min.svg"
            data-src="images/image_5.png"
            data-srcset="/posts/flare-on-7-break/images/image_5.png, images/image_5.png 1.5x, /posts/flare-on-7-break/images/image_5.png 2x"
            data-sizes="auto"
            alt="/posts/flare-on-7-break/images/image_5.png" />
    </a>
<p>This function simply loads <code>ptrace</code> and passes its arguments to it. So we&rsquo;ll refer to this function as <code>ptrace</code> from now on.</p>
<p>The first thing <em>child1</em> does is to call <code>ptrace</code> with the <em>parent</em>&rsquo;s PID as an argument, and the request of type <code>0x10</code>.</p>
<div class="highlight"><pre class="chroma"><code class="language-asm" data-lang="asm"><span class="nf">push</span>    <span class="mi">0</span>
<span class="nf">push</span>    <span class="mi">0</span>
<span class="nf">push</span>    <span class="p">[</span><span class="no">ebp</span><span class="err">+</span><span class="no">parent_pid</span><span class="p">]</span>
<span class="nf">push</span>    <span class="mi">10</span><span class="no">h</span>
<span class="nf">call</span>    <span class="no">ptrace</span>
</code></pre></div><p>A nice tip here, if you&rsquo;re using IDA Pro, is to click the <code>10h</code> constant and hit <code>M</code> on the keyboard, then you&rsquo;ll be able to choose the right enumeration for this constant (<code>__ptrace_request</code> in our case) and this will show you the symbol name for this constant number (will work in the Decompiler as well). By doing that, we&rsquo;ll get a more meaningful code.</p>
<div class="highlight"><pre class="chroma"><code class="language-asm" data-lang="asm"><span class="nf">push</span>    <span class="mi">0</span>
<span class="nf">push</span>    <span class="mi">0</span>
<span class="nf">push</span>    <span class="p">[</span><span class="no">ebp</span><span class="err">+</span><span class="no">parent_pid</span><span class="p">]</span>
<span class="nf">push</span>    <span class="no">PTRACE_ATTACH</span>
<span class="nf">call</span>    <span class="no">ptrace</span>
</code></pre></div><p>Now it&rsquo;s very easy to see that <em>child1</em> will attach to the parent using <code>ptrace</code>, which is to be expected based on the call to <code>prctl</code> we saw in the parent.</p>
<p>In case <em>child1</em> fails to ptrace the parent (can happen if it&rsquo;s already being ptraced), it will either kill the ptracer or quit the program altogether. Things start to get interesting when child1 does ptrace the parent.</p>
<p>From this point on, we&rsquo;d like to look at the code in the order in which it&rsquo;s being executed, so we&rsquo;ll be jumping between processes and functions quite a lot. We&rsquo;ll also refer to the function at <code>0080490C4</code> as <code>child1_main</code> for convenience.</p>
<p>The next thing that child1 does in <code>child1_main</code> is the following:</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">if</span> <span class="p">(</span> <span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_POKEDATA</span><span class="p">,</span> <span class="n">parent_pid</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">check_input</span><span class="p">,</span> <span class="mh">0xB0F</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0xFFFFFFFF</span> <span class="p">)</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</code></pre></div><p>Based on the man page of <code>ptrace</code>, <code>PTRACE_POKEDATA</code> basically copies the word from the 4th argument to the address from the 3rd argument to the process which its PID we get in the 2nd parameter. This means that child1 will write <code>0xB0F</code> to the start of the function <code>check_input</code> (based in <code>0x08048CDB</code>) that we saw before. These bytes do not produce a valid x86 instruction, so it&rsquo;ll cause the parent process to execute illegal code when it starts running again (remember that since we attached to the parent using <code>ptrace</code>, it&rsquo;s now suspended until we&rsquo;ll send some ptrace request that will cause the execution to resume.
This is followed by a call to the function at <code>0804A0B4</code> which looks quite similar to our initialization function.</p>
<a class="lightgallery" href="/posts/flare-on-7-break/images/image_6.png" title="/posts/flare-on-7-break/images/image_6.png" data-thumbnail="/posts/flare-on-7-break/images/image_6.png">
        <img
            class="lazyload"
            src="/svg/loading.min.svg"
            data-src="images/image_6.png"
            data-srcset="/posts/flare-on-7-break/images/image_6.png, images/image_6.png 1.5x, /posts/flare-on-7-break/images/image_6.png 2x"
            data-sizes="auto"
            alt="/posts/flare-on-7-break/images/image_6.png" />
    </a>
<p>This function will <code>fork</code> again, make the forked process - <em>child2</em> execute the code starting at <code>008049C9C</code> (we&rsquo;ll call this <code>child2_main</code>) and set <em>child2</em> as the ptracer of child1. So we have <em>parent</em> that creates <em>child1</em>, and <em>child1</em> which creates <em>child2.</em> And every child in this tree <code>ptrace</code> its parent so <em>child1</em> <code>ptrace</code> <em>parent</em> and <em>child2</em> <code>ptrace</code> <em>child1.</em></p>
<div class="details admonition tip open">
        <div class="details-summary admonition-title">
            <i class="icon fas fa-lightbulb fa-fw"></i>Tip<i class="details-icon fas fa-angle-right fa-fw"></i>
        </div>
        <div class="details-content">
            <div class="admonition-content"><p>Some of the readers will recognize this set of parent-child debugging techniques as &ldquo;Nanomites&rdquo;. It is a software protection technique that became popular thanks to the Armadillo protector. For further reading, we recommend the following posts:</p>
<ul>
<li><a href="https://malwareandstuff.com/nanomites-on-linux" target="_blank" rel="noopener noreffer">Nanomites on Linux</a></li>
<li><a href="https://www.codeproject.com/Articles/621236/Nanomite-and-Debug-Blocker-for-Linux-Applications" target="_blank" rel="noopener noreffer">Nanomite and Debug Blocker for Linux Applications</a></li>
</ul>
</div>
        </div>
    </div>
<p>We&rsquo;ll get back to <em>child2</em> later, for now, we stick to analyzing <em>child1</em> which continues by doing the following:</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_SYSEMU</span><span class="p">,</span> <span class="n">parent_pid</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</code></pre></div><p><code>PTRACE_SYSEMU</code> is a request to emulate the ptraced process' syscalls - <strong>every syscall the parent will make, child1 will get a trap signal and be able to control the values the parent will get back from it.</strong> At this point, <em>child1</em> will call <code>waitpid()</code> in an infinite loop, to wait for signals from the parent process so let&rsquo;s see what it&rsquo;s up to.</p>
<h1 id="stage-1">Stage 1</h1>
<h2 id="understanding-syscall-emulation">Understanding Syscall Emulation</h2>
<p>After returning from the initialization function, <em>parent</em> will execute its <code>main</code> starting with a call to <code>puts()</code> to print out the welcome message. Many <em>glibc</em> functions ultimately use Linux system calls in order to execute their logic on the system. So for example <code>puts()</code> will use the <code>write</code> system call in order to write to the desired file descriptor that the user-provided. Since <em>glibc</em> is open-source, you can go and look for yourself at the function code, and see which system call it invokes during its execution. Another option is to use <code>strace</code> on a tiny program that will call the <em>glibc</em> function (<code>puts()</code> for instance) which will let you know exactly what system calls are involved in the function of interest. Before we dive in, let&rsquo;s make sure we remember how system calls work in x86. A system call is an <code>int 0x80</code> instruction while the type of system call is being passed to the kernel using the <code>eax</code> register. For the <code>write</code> syscall <code>eax</code> should be set to <code>4</code> (you can find syscall constants based on architecture type <a href="https://chromium.googlesource.com/chromiumos/docs/&#43;/master/constants/syscalls.md#cross_arch-numbers" target="_blank" rel="noopener noreffer">here</a>). Every syscall can also accept arguments, which are being passed in <code>ebx</code>, <code>ecx</code>, <code>edx</code>, <code>esi</code>, <code>edi</code>, <code>ebp</code> accordingly. This out of the way, now the execution goes back to <em>child1</em> since <em>parent</em> made a syscall which sent a <code>SIGTRAP</code> to <em>child1.</em> After <em>child1</em> called <code>waitpid()</code> and got a signal, it&rsquo;ll check its type and in case of a <code>SIGTRAP</code> (that in this case is sent due to the syscall) it&rsquo;ll do the following (from <code>child1_main</code>):</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">if</span> <span class="p">(</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="mh">0xFF00</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span> <span class="o">==</span> <span class="n">SIGTRAP</span> <span class="p">)</span>
<span class="p">{</span>
  <span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_GETREGS</span><span class="p">,</span> <span class="n">parent_pid</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">&amp;</span><span class="n">v15</span><span class="p">);</span>
</code></pre></div><p>This ptrace request will get the values of all the <em>parent</em> process registers into the 4th argument. Looking at the documentation we can see that it&rsquo;s of type <code>user_regs_struct</code>, so let&rsquo;s hit <code>Y</code> on that variable in IDA Pro and set <code>v15</code> to be of that type, and also we&rsquo;ll rename it to <code>parent_regs</code>. Now the code looks better.</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">if</span> <span class="p">(</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="mh">0xFF00</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span> <span class="o">==</span> <span class="n">SIGTRAP</span> <span class="p">)</span> <span class="c1">// Trace trap
</span><span class="c1"></span><span class="p">{</span>
  <span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_GETREGS</span><span class="p">,</span> <span class="n">parent_pid</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">&amp;</span><span class="n">parent_regs</span><span class="p">);</span>
  <span class="n">last_instruction</span> <span class="o">=</span> <span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_PEEKDATA</span><span class="p">,</span> <span class="n">parent_pid</span><span class="p">,</span> <span class="n">parent_regs</span><span class="p">.</span><span class="n">eip</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span><span class="c1">// Read data
</span><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span> <span class="n">last_instruction</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="p">)</span>
    <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kr">__int8</span><span class="p">)</span><span class="n">last_instruction</span> <span class="o">==</span> <span class="mh">0xCC</span> <span class="p">)</span><span class="c1">// If software breakpoint
</span><span class="c1"></span>  <span class="p">{</span>
    <span class="n">kill</span><span class="p">(</span><span class="n">parent_pid</span><span class="p">,</span> <span class="n">SIGKILL</span><span class="p">);</span>
    <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="n">magic</span> <span class="o">=</span> <span class="mh">0x1337CAFE</span> <span class="o">*</span> <span class="p">(</span><span class="n">parent_regs</span><span class="p">.</span><span class="n">orig_eax</span> <span class="o">^</span> <span class="mh">0xDEADBEEF</span><span class="p">);</span>
</code></pre></div><p>Next, <em>child1</em> uses <code>ptrace()</code> yet again, this time with a request to <code>PTRACE_PEEKDATA</code> which will read a word from the address in the 3rd parameter in the <em>parent</em>. The address from which it reads is parent_regs<code>.eip - 1</code> which means it&rsquo;ll read the last instruction executed. In case it was <code>0xCC</code>(int 3) it will kill the parent and exit. Otherwise, it will take the syscall type stored in <code>eax</code> and xor and multiply it with constant values to create a magic number that will be used to determine its next steps. Next in <code>child1_main</code> we see a bunch of <em>if</em> and <em>switch</em> statements that will execute the correct logic based on the original system call type. To understand what relevant code path will be taken in our <code>write</code> syscall case, we&rsquo;ll do the math first.</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">Python</span><span class="o">&gt;</span> <span class="mh">0x1337CAFE</span> <span class="o">*</span> <span class="p">(</span><span class="mi">4</span> <span class="o">^</span> <span class="mh">0xDEADBEEF</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xffffffff</span> <span class="c1"># 4 == WRITE</span>
<span class="mh">0x7e85db2a</span>
</code></pre></div><p>Then we can quickly search for this value to locate the correct code path within the function (you can either skim through the function manually or use <code>Alt+I</code> to search for this immediate value in IDA). This will bring us here:</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">case</span> <span class="mh">0x7E85DB2A</span><span class="o">:</span>
	<span class="n">size</span> <span class="o">=</span> <span class="n">parent_regs</span><span class="p">.</span><span class="n">edx</span><span class="p">;</span>
	<span class="n">buf</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">parent_regs</span><span class="p">.</span><span class="n">edx</span><span class="p">);</span>
	<span class="n">sub_804BBF8</span><span class="p">(</span><span class="n">parent_pid</span><span class="p">,</span> <span class="n">parent_regs</span><span class="p">.</span><span class="n">ecx</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="n">write</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="n">parent_regs</span><span class="p">.</span><span class="n">eax</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
	<span class="n">ptrace</span><span class="p">(</span><span class="mi">13</span><span class="p">,</span> <span class="n">parent_pid</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">&amp;</span><span class="n">parent_regs</span><span class="p">);</span>
	<span class="n">free</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
	<span class="k">break</span><span class="p">;</span>
</code></pre></div><p>First, we&rsquo;ll make the decompiled code look s bit better by renaming variables and applying the correct enum symbols. Since this code is fairly simple - let&rsquo;s have a look at <code>sub_804BBF8</code> to fully understand it. It accepts 4 arguments - the <em>parent</em> PID, <code>ecx</code> from of <em>parent</em> (which is the second argument for the system call - our buffer pointer in <code>write</code>, a pointer to the newly allocated buffer, and the size which we get from the 3rd argument of the <code>write</code> syscall. If we go to <code>sub_804BBF8</code> and rename its arguments, we can quite easily understand what it&rsquo;s doing.</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">for</span> <span class="p">(</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span> <span class="o">/</span> <span class="mi">4</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span> <span class="p">)</span>
<span class="p">{</span>
  <span class="o">*</span><span class="n">new_buffer</span> <span class="o">=</span> <span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_PEEKDATA</span><span class="p">,</span> <span class="n">parent_pid</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="n">buffer</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">;</span>
  <span class="o">++</span><span class="n">new_buffer</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)(</span><span class="n">size</span> <span class="o">%</span> <span class="mi">4</span><span class="p">);</span>
<span class="n">v8</span> <span class="o">=</span> <span class="n">size</span> <span class="o">%</span> <span class="mi">4</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span> <span class="n">size</span> <span class="o">%</span> <span class="mi">4</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">)</span>
  <span class="n">v7</span> <span class="o">=</span> <span class="mi">255</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span> <span class="n">v8</span> <span class="o">==</span> <span class="mi">2</span> <span class="p">)</span>
  <span class="n">v7</span> <span class="o">=</span> <span class="mh">0xFFFF</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span> <span class="n">v8</span> <span class="o">==</span> <span class="mi">3</span> <span class="p">)</span>
  <span class="n">v7</span> <span class="o">=</span> <span class="mh">0xFFFFFF</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span> <span class="n">v8</span> <span class="p">)</span>
<span class="p">{</span>
  <span class="n">v5</span> <span class="o">=</span> <span class="n">v7</span> <span class="o">&amp;</span> <span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_PEEKDATA</span><span class="p">,</span> <span class="n">parent_pid</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">|</span> <span class="o">~</span><span class="n">v7</span> <span class="o">&amp;</span> <span class="o">*</span><span class="n">new_buffer</span><span class="p">;</span>
  <span class="n">result</span> <span class="o">=</span> <span class="n">new_buffer</span><span class="p">;</span>
  <span class="o">*</span><span class="n">new_buffer</span> <span class="o">=</span> <span class="n">v5</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
</code></pre></div><p>Here <em>child1</em> is using the ptrace request <code>PTRACE_PEEKDATA</code> to read data from <em>parent,</em> 4 bytes at a time from within the loop, and the remainder of the data after it. We can rename <code>sub_804BBF8</code> to <code>copy_from_pid</code> so it&rsquo;ll be easier to recognize later. Getting back to our case that handles the <code>write</code> syscall we can immediately tell that it simply emulates the <code>write</code> syscall for the <em>parent -</em> allocating a buffer for the string to be written, copying this string from the <em>parent</em> memory space, calling <code>write()</code>, and finally putting the number of written bytes into <code>eax</code> and setting the new state of the registers using the request <code>PTRACE_SETREGS</code>.</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">case</span> <span class="mh">0x7E85DB2A</span><span class="o">:</span>
	<span class="n">size</span> <span class="o">=</span> <span class="n">parent_regs</span><span class="p">.</span><span class="n">edx</span><span class="p">;</span>
	<span class="n">buf</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">parent_regs</span><span class="p">.</span><span class="n">edx</span><span class="p">);</span>
	<span class="n">copy_from_pid</span><span class="p">(</span><span class="n">parent_pid</span><span class="p">,</span> <span class="n">parent_regs</span><span class="p">.</span><span class="n">ecx</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span><span class="n">buf</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="n">write</span><span class="p">(</span><span class="n">STDOUT_FILENO</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="n">parent_regs</span><span class="p">.</span><span class="n">eax</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
	<span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_SETREGS</span><span class="p">,</span> <span class="n">parent_pid</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">&amp;</span><span class="n">parent_regs</span><span class="p">);</span>
	<span class="n">free</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
	<span class="k">break</span><span class="p">;</span>
</code></pre></div><p>Now we understand the concept of how <em>child1</em> can emulate system calls for the <em>parent</em> and we&rsquo;ll continue to look at the <em>parent&rsquo;s <code>main</code>.</em></p>
<p>After a few <code>write</code> system calls which <em>child1</em> will simply emulate, we get to the first <code>read()</code>. Going back to our <a href="https://chromium.googlesource.com/chromiumos/docs/&#43;/master/constants/syscalls.md#Cross_arch-Numbers" target="_blank" rel="noopener noreffer">syscall table</a>, we see that this one has the constant <code>3</code> in x86, so we&rsquo;ll use that to get our magic value again.</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">Python</span><span class="o">&gt;</span> <span class="mh">0x1337CAFE</span> <span class="o">*</span> <span class="p">(</span><span class="mi">3</span> <span class="o">^</span> <span class="mh">0xDEADBEEF</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xffffffff</span> <span class="c1"># 3 == READ</span>
<span class="mh">0x91bda628</span>
</code></pre></div><p>Which will bring us to this code (<code>chil1_main</code>):</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">else</span> <span class="nf">if</span> <span class="p">(</span> <span class="n">magic</span> <span class="o">==</span> <span class="mh">0x91BDA628</span> <span class="p">)</span>
<span class="p">{</span>
  <span class="n">fgets</span><span class="p">(</span><span class="n">byte_81A56C0</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="n">stdin</span><span class="p">);</span>
  <span class="n">s</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">sub_804C438</span><span class="p">(</span><span class="mh">0xB8</span><span class="p">);</span>
  <span class="n">dword_81A57C0</span> <span class="o">=</span> <span class="n">parent_regs</span><span class="p">.</span><span class="n">ecx</span><span class="p">;</span>
  <span class="n">v3</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
  <span class="n">sub_804BB2D</span><span class="p">(</span><span class="n">parent_pid</span><span class="p">,</span> <span class="n">parent_regs</span><span class="p">.</span><span class="n">ecx</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span><span class="n">s</span><span class="p">,</span> <span class="n">v3</span><span class="p">);</span>
  <span class="n">parent_regs</span><span class="p">.</span><span class="n">eax</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
  <span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_SETREGS</span><span class="p">,</span> <span class="n">parent_pid</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">&amp;</span><span class="n">parent_regs</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>As you can see, the first action <em>child1</em> takes here is also to emulate the <code>read</code> syscall for the <em>parent</em> using by calling <code>fgets()</code>. We&rsquo;ll rename <code>byte_81A56C0</code> to <code>input_buffer</code> since this is the buffer that&rsquo;ll hold the user input. At this point, looks like <em>child1</em> gets a string from <code>sub_804C438</code> and stores the 2nd argument from the <code>read</code> syscall in <code>dword_81A57C0</code> (from <code>ecx</code>); let&rsquo;s call this the <code>parent_input_buffer</code> since this is where the <em>parent</em> expects to get the user input into. Finally, <em>child1</em> calls <code>sub_804BB2D</code>, and returns the length of the string it got from <code>sub_804C438</code> by setting <code>eax</code> and requesting <code>PTRACE_SETREGS</code>. In order to fully understand the logic here, we&rsquo;ll have to examine the two unknown functions. Starting with <code>sub_804BB2D</code>:</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">for</span> <span class="p">(</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">a4</span> <span class="o">/</span> <span class="mi">4</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span> <span class="p">)</span>
  <span class="p">{</span>
    <span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_POKEDATA</span><span class="p">,</span> <span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">,</span> <span class="o">*</span><span class="n">a3</span><span class="p">);</span>
    <span class="n">a2</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">;</span>
    <span class="o">++</span><span class="n">a3</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">result</span> <span class="o">=</span> <span class="n">a4</span> <span class="o">%</span> <span class="mi">4</span><span class="p">;</span>
  <span class="n">v8</span> <span class="o">=</span> <span class="n">a4</span> <span class="o">%</span> <span class="mi">4</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span> <span class="n">a4</span> <span class="o">%</span> <span class="mi">4</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">)</span>
    <span class="n">v7</span> <span class="o">=</span> <span class="mi">255</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span> <span class="n">v8</span> <span class="o">==</span> <span class="mi">2</span> <span class="p">)</span>
    <span class="n">v7</span> <span class="o">=</span> <span class="mh">0xFFFF</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span> <span class="n">v8</span> <span class="o">==</span> <span class="mi">3</span> <span class="p">)</span>
    <span class="n">v7</span> <span class="o">=</span> <span class="mh">0xFFFFFF</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span> <span class="n">v8</span> <span class="p">)</span>
  <span class="p">{</span>
    <span class="n">v5</span> <span class="o">=</span> <span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_PEEKDATA</span><span class="p">,</span> <span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_POKEDATA</span><span class="p">,</span> <span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">,</span> <span class="n">v5</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">v7</span> <span class="o">|</span> <span class="n">v7</span> <span class="o">&amp;</span> <span class="o">*</span><span class="n">a3</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
</code></pre></div><p>It looks rather similar to a function we already analyzed - <code>copy_from_pid</code>, but the difference is the usage of <code>PTRACE_POKEDATA</code> instead of <code>PTRACE_PEEKDATA</code> which is used to write data instead of reading it. So this function writes data into the given PID, and thus we&rsquo;ll rename it to <code>copy_to_pid</code>.</p>
<p>Now it becomes clear that <em>child1</em> reads data from the user and stores it in its memory space in <code>input_buffer</code>, but what it returns to the <em>parent</em> is a completely different string which it gets from the function <code>sub_804C438</code>. If we paid close attention this far, we may already assume that the string it returns to the <em>parent</em> is <em>&lsquo;sorry i stole your input :)'</em>  due to the output we saw when executing this binary, but since this function is being called quite a lot throughout the binary, it&rsquo;s better to analyze it.</p>
<h2 id="string-encryption">String Encryption</h2>
<p>The pseudo-code looks like this:</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">_BYTE</span> <span class="o">*</span><span class="kr">__cdecl</span> <span class="nf">get_string</span><span class="p">(</span><span class="kt">int</span> <span class="n">a1</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">v10</span> <span class="o">=</span> <span class="n">__readgsdword</span><span class="p">(</span><span class="mh">0x14u</span><span class="p">);</span>
  <span class="n">index</span> <span class="o">=</span> <span class="n">a1</span> <span class="o">^</span> <span class="mh">0xAA</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span> <span class="p">(</span><span class="n">index</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">)</span>
  <span class="p">{</span>
    <span class="n">encrypted_len</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">((</span><span class="o">&amp;</span><span class="n">string_array</span><span class="p">)[</span><span class="n">index</span><span class="p">]);</span>
    <span class="n">decrypted</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">encrypted_len</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span>
    <span class="n">encrypted</span> <span class="o">=</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">string_array</span><span class="p">)[</span><span class="n">index</span><span class="p">];</span>
    <span class="k">for</span> <span class="p">(</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">encrypted_len</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">&gt;</span> <span class="n">i</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span> <span class="p">)</span>
      <span class="n">decrypted</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">MEMORY</span><span class="p">[</span><span class="mi">0</span><span class="p">](</span><span class="mh">0x91BDA628</span><span class="p">,</span> <span class="n">encrypted</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">i</span><span class="p">],</span> <span class="n">encrypted</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]);</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">decrypted</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">else</span>
  <span class="p">{</span>
    <span class="n">v4</span> <span class="o">=</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">string_array</span><span class="p">)[</span><span class="n">index</span><span class="p">];</span>
    <span class="n">sub_804A372</span><span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="n">v9</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">v4</span><span class="p">);</span>
    <span class="n">dest</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="o">*</span><span class="p">((</span><span class="n">_DWORD</span> <span class="o">*</span><span class="p">)</span><span class="n">v4</span> <span class="o">+</span> <span class="mi">4</span><span class="p">));</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="n">dest</span><span class="p">,</span> <span class="n">v4</span> <span class="o">+</span> <span class="mi">20</span><span class="p">,</span> <span class="o">*</span><span class="p">((</span><span class="n">_DWORD</span> <span class="o">*</span><span class="p">)</span><span class="n">v4</span> <span class="o">+</span> <span class="mi">4</span><span class="p">));</span>
    <span class="k">for</span> <span class="p">(</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="o">*</span><span class="p">((</span><span class="n">_DWORD</span> <span class="o">*</span><span class="p">)</span><span class="n">v4</span> <span class="o">+</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">j</span><span class="p">;</span> <span class="n">j</span> <span class="o">+=</span> <span class="mi">16</span> <span class="p">)</span>
      <span class="n">sub_804B228</span><span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="n">v9</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">dest</span> <span class="o">+</span> <span class="n">j</span><span class="p">);</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">dest</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>Since <code>sub_804C438</code>&rsquo;s purpose is basically to get a string, we&rsquo;ll rename to <code>get_string</code>. We can see that the argument that&rsquo;s passed to this function is being XORed with <code>0xAA</code>, and then used as an index in an array of strings located at <code>off_81A5140</code>. The string we get using this index is then being decrypted in one of two ways; one for even indices and another for odd ones. Let&rsquo;s first have a look at how odd indexed strings are decrypted, by looking at the if clause (renaming a few variables for convenience):</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">encrypted_len</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">((</span><span class="o">&amp;</span><span class="n">string_array</span><span class="p">)[</span><span class="n">index</span><span class="p">]);</span>
<span class="n">decrypted</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">encrypted_len</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span>
<span class="n">encrypted</span> <span class="o">=</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">string_array</span><span class="p">)[</span><span class="n">index</span><span class="p">];</span>
<span class="k">for</span> <span class="p">(</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">encrypted_len</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">&gt;</span> <span class="n">i</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span> <span class="p">)</span>
  <span class="n">decrypted</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">MEMORY</span><span class="p">[</span><span class="mi">0</span><span class="p">](</span><span class="mh">0x91BDA628</span><span class="p">,</span> <span class="n">encrypted</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">i</span><span class="p">],</span> <span class="n">encrypted</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]);</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">decrypted</span><span class="p">;</span>
</code></pre></div><p>Seems like this gets the string from the <code>strings_array</code>, then allocates a new buffer that&rsquo;s half the size of the encrypted string, then iterates over the encrypted string, decrypting two bytes at a time and returning the decrypted/decoded string as the result of the function. But wait, what does calling <code>MEMORY[0]</code> means? Usually, when you see something that doesn&rsquo;t seem to make much sense in the decompiler, it&rsquo;s better going to the disassembler and examine it yourself.</p>
<a class="lightgallery" href="/posts/flare-on-7-break/images/image_7.png" title="/posts/flare-on-7-break/images/image_7.png" data-thumbnail="/posts/flare-on-7-break/images/image_7.png">
        <img
            class="lazyload"
            src="/svg/loading.min.svg"
            data-src="images/image_7.png"
            data-srcset="/posts/flare-on-7-break/images/image_7.png, images/image_7.png 1.5x, /posts/flare-on-7-break/images/image_7.png 2x"
            data-sizes="auto"
            alt="/posts/flare-on-7-break/images/image_7.png" />
    </a>
<p>Looking at the relevant basic block, we see this call as a <code>call eax</code>, and we see the value of <code>eax</code> being set to <code>var_D4</code> right before that. An easy way to quickly navigate the code and see what&rsquo;s in <code>var_D4</code> is having the cursor over it and hitting <code>Alt+Up</code> in order to go to the previous location in which it was used. This brings us to this instruction:</p>
<div class="highlight"><pre class="chroma"><code class="language-asm" data-lang="asm"><span class="nl">.text:</span><span class="err">0804</span><span class="nf">C453</span>   <span class="no">mov</span>     <span class="p">[</span><span class="no">ebp</span><span class="err">+</span><span class="no">var_D4</span><span class="p">],</span> <span class="mi">0</span>
</code></pre></div><p>Looks like we really have a call to address zero, and as you probably know, this is an invalid memory reference since no code is loaded at this location. What&rsquo;s going on here?</p>
<p>Knowing the nature of this challenge after seeing that <em>child1</em> handles signals from <em>parent</em> and keeping in mind the fact that <em>child1</em> forked once more and we put aside that analysis of the second forked process, we may assume that the second forked process can potentially handle this invalid memory reference signal from <em>child1</em>. Enter <em>child2</em>.</p>
<h2 id="analyzing-child2">Analyzing <em>child2</em></h2>
<p>Let&rsquo;s have a look at <code>child2_main</code> and see if we see some logic that might be related to the issue at hand.</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">prctl</span><span class="p">(</span><span class="n">PR_SET_DUMPABLE</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">signal</span><span class="p">(</span><span class="n">PTRACE_PEEKDATA</span><span class="p">,</span> <span class="p">(</span><span class="n">__sighandler_t</span><span class="p">)</span><span class="mi">1</span><span class="p">);</span>
<span class="n">signal</span><span class="p">(</span><span class="n">PTRACE_PEEKUSER</span><span class="p">,</span> <span class="p">(</span><span class="n">__sighandler_t</span><span class="p">)</span><span class="mi">1</span><span class="p">);</span>
<span class="n">signal</span><span class="p">(</span><span class="n">PTRACE_SETFPREGS</span><span class="p">,</span> <span class="p">(</span><span class="n">__sighandler_t</span><span class="p">)</span><span class="mi">1</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span> <span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_ATTACH</span><span class="p">,</span> <span class="n">child1_pid</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="p">)</span>
<span class="p">{</span>
  <span class="k">while</span> <span class="p">(</span> <span class="mi">1</span> <span class="p">)</span>
  <span class="p">{</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">waitpid</span><span class="p">(</span><span class="n">child1_pid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">status</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">result</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="p">)</span>
      <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
    <span class="n">v5</span> <span class="o">=</span> <span class="n">status</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kr">__int8</span><span class="p">)</span><span class="n">status</span> <span class="o">==</span> <span class="mh">0x7F</span> <span class="p">)</span>    <span class="c1">// is WTERMSIG
</span><span class="c1"></span>    <span class="p">{</span>
      <span class="n">v6</span> <span class="o">=</span> <span class="n">status</span><span class="p">;</span>
      <span class="n">signal</span> <span class="o">=</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="mh">0xFF00</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">;</span>
      <span class="n">qmemcpy</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&#34;I HAVE THE CONCH DON&#34;</span><span class="p">,</span> <span class="mi">20</span><span class="p">);</span>
      <span class="n">s</span><span class="p">[</span><span class="mi">20</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kr">__int8</span><span class="p">)</span><span class="s">&#34;&#39;&#34;</span><span class="p">;</span>
      <span class="n">strcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">[</span><span class="mi">21</span><span class="p">],</span> <span class="s">&#34;T INTERRUPT ME&#34;</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span> <span class="n">signal</span> <span class="o">==</span> <span class="n">SIGSEGV</span> <span class="p">)</span>                <span class="c1">// invalid memory reference
</span><span class="c1"></span>      <span class="p">{</span>
        <span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_GETREGS</span><span class="p">,</span> <span class="n">child1_pid</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">&amp;</span><span class="n">child1_regs</span><span class="p">);</span>
        <span class="n">v11</span> <span class="o">=</span> <span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_PEEKDATA</span><span class="p">,</span> <span class="n">child1_pid</span><span class="p">,</span> <span class="n">child1_regs</span><span class="p">.</span><span class="n">esp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
        <span class="n">v10</span> <span class="o">=</span> <span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_PEEKDATA</span><span class="p">,</span> <span class="n">child1_pid</span><span class="p">,</span> <span class="n">child1_regs</span><span class="p">.</span><span class="n">esp</span> <span class="o">+</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
        <span class="n">buffer</span> <span class="o">=</span> <span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_PEEKDATA</span><span class="p">,</span> <span class="n">child1_pid</span><span class="p">,</span> <span class="n">child1_regs</span><span class="p">.</span><span class="n">esp</span> <span class="o">+</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
        <span class="n">v8</span> <span class="o">=</span> <span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_PEEKDATA</span><span class="p">,</span> <span class="n">child1_pid</span><span class="p">,</span> <span class="n">child1_regs</span><span class="p">.</span><span class="n">esp</span> <span class="o">+</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">[.</span> <span class="p">.</span> <span class="p">.]</span>
</code></pre></div><p>Here too, we can see that <em>child2</em> is attaching to <em>child1,</em> and waits for signals. The interesting part starts when we have a <code>SIGSEGV</code> which is an invalid memory reference (like the one we actually saw in <em>child1</em>). First, <em>child2</em> get the registers of <em>child1</em> using <code>ptrace</code>, and then it reads 4 values off the stack using the request <code>PTRACE_PEEKDATA</code>. The first argument is the return address of course, then we get the second one which is being used as a magic number again to decide which code path to take using a switch statement, finally, we have two more values that will be used as arguments. So we&rsquo;ll rename those local variables accordingly and keep looking at the rest of the code.</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">if</span> <span class="p">(</span> <span class="n">signal</span> <span class="o">==</span> <span class="n">SIGSEGV</span> <span class="p">)</span>                <span class="c1">// invalid memory references
</span><span class="c1"></span><span class="p">{</span>
	<span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_GETREGS</span><span class="p">,</span> <span class="n">child1_pid</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">&amp;</span><span class="n">child1_regs</span><span class="p">);</span>
	<span class="n">ret_addr</span> <span class="o">=</span> <span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_PEEKDATA</span><span class="p">,</span> <span class="n">child1_pid</span><span class="p">,</span> <span class="n">child1_regs</span><span class="p">.</span><span class="n">esp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">magic</span> <span class="o">=</span> <span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_PEEKDATA</span><span class="p">,</span> <span class="n">child1_pid</span><span class="p">,</span> <span class="n">child1_regs</span><span class="p">.</span><span class="n">esp</span> <span class="o">+</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">arg1</span> <span class="o">=</span> <span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_PEEKDATA</span><span class="p">,</span> <span class="n">child1_pid</span><span class="p">,</span> <span class="n">child1_regs</span><span class="p">.</span><span class="n">esp</span> <span class="o">+</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">arg2</span> <span class="o">=</span> <span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_PEEKDATA</span><span class="p">,</span> <span class="n">child1_pid</span><span class="p">,</span> <span class="n">child1_regs</span><span class="p">.</span><span class="n">esp</span> <span class="o">+</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="k">while</span> <span class="p">(</span> <span class="n">child1_regs</span><span class="p">.</span><span class="n">eip</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="p">)</span>
  <span class="p">;</span>
<span class="k">if</span> <span class="p">(</span> <span class="n">magic</span> <span class="o">==</span> <span class="mh">0x44DE7A30</span> <span class="p">)</span>
<span class="p">{</span>
  <span class="n">child1_regs</span><span class="p">.</span><span class="n">eax</span> <span class="o">=</span> <span class="n">arg2</span> <span class="o">^</span> <span class="n">arg1</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">else</span> <span class="nf">if</span> <span class="p">(</span> <span class="n">magic</span> <span class="o">&gt;</span> <span class="mh">0x44DE7A30</span> <span class="p">)</span>
<span class="p">{</span>
  <span class="k">switch</span> <span class="p">(</span> <span class="n">magic</span> <span class="p">)</span>
  <span class="p">{</span>
    <span class="k">case</span> <span class="mh">0x6B4E102C</span><span class="o">:</span>
      <span class="n">child1_regs</span><span class="p">.</span><span class="n">eax</span> <span class="o">=</span> <span class="n">arg1</span> <span class="o">+</span> <span class="n">arg2</span><span class="p">;</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="mh">0x7E85DB2A</span><span class="o">:</span>
      <span class="n">child1_regs</span><span class="p">.</span><span class="n">eax</span> <span class="o">=</span> <span class="mh">0x9E3779B9</span><span class="p">;</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="mh">0x5816452E</span><span class="o">:</span>
      <span class="n">child1_regs</span><span class="p">.</span><span class="n">eax</span> <span class="o">=</span> <span class="n">sub_804C163</span><span class="p">(</span><span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">);</span>
      <span class="k">break</span><span class="p">;</span>
  <span class="p">}</span>
<span class="k">else</span>
<span class="p">{</span>
  <span class="k">switch</span> <span class="p">(</span> <span class="n">magic</span> <span class="p">)</span>
  <span class="p">{</span>
    <span class="k">case</span> <span class="mh">0xA4F57126</span><span class="o">:</span>
      <span class="n">child1_regs</span><span class="p">.</span><span class="n">eax</span> <span class="o">=</span> <span class="n">arg2</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span> <span class="n">arg2</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="p">)</span>
      <span class="p">{</span>
        <span class="n">copy_from_pid</span><span class="p">(</span><span class="n">child1_pid</span><span class="p">,</span> <span class="n">arg1</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span><span class="n">new_buffer</span><span class="p">,</span> <span class="mi">62</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">strncmp</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="s">&#34;@no-flare.com&#34;</span><span class="p">,</span> <span class="mh">0xDu</span><span class="p">)</span> <span class="p">)</span>
          <span class="n">child1_regs</span><span class="p">.</span><span class="n">eax</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="mh">0xB82D3C24</span><span class="o">:</span>
      <span class="n">child1_regs</span><span class="p">.</span><span class="n">eax</span> <span class="o">=</span> <span class="n">arg1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="mh">0x91BDA628</span><span class="o">:</span>
      <span class="n">child1_regs</span><span class="p">.</span><span class="n">eax</span> <span class="o">=</span> <span class="p">(</span><span class="mh">0x10</span> <span class="o">*</span> <span class="p">(</span><span class="n">arg1</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">|</span> <span class="p">((</span><span class="n">_BYTE</span><span class="p">)</span><span class="n">arg2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xF</span><span class="p">;</span>
      <span class="k">break</span><span class="p">;</span>
  <span class="p">}</span>
<span class="n">child1_regs</span><span class="p">.</span><span class="n">eip</span> <span class="o">=</span> <span class="n">ret_addr</span><span class="p">;</span>
<span class="n">child1_regs</span><span class="p">.</span><span class="n">esp</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">;</span>
<span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_SETREGS</span><span class="p">,</span> <span class="n">child1_pid</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">&amp;</span><span class="n">child1_regs</span><span class="p">);</span>
<span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_CONT</span><span class="p">,</span> <span class="n">child1_pid</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</code></pre></div><p>We can see that there are a few cases for different magic numbers, each of the cases will perform rather simple arithmetic operations on the arguments. The operations are very simple and usually involve changing a register or two. Understanding this, we can ask ourselves a very simple and important question: Can we get rid of <em>child2</em> and move these operations to <em>child1</em>? Well, the answer is yes.</p>
<h2 id="getting-rid-of-the-child2">Getting Rid of the <em>child2</em></h2>
<p>The importance of getting rid of <em>child2</em> so early in the analysis is that we are removing the debugger that debugged <em>child1</em>, and this will allow us to take control and attach a debugger to the <em>child1</em>. But this, of course, comes with the price. We need to carefully make sure that we are not losing functionality when removing <em>child2</em>. This is because the flow of the program strongly relies on the arithmetic operations done in <em>child2</em> — without it, the challenge won&rsquo;t work.</p>
<p>Let&rsquo;s do a quick recap of how does <em>child1</em> gives control to <em>child2</em>. To demonstrate it, we can use the handler of the magic value <code>0x7E85DB2A</code>. This value is triggered by <em>child1</em> in a code that looks like this:</p>
<div class="highlight"><pre class="chroma"><code class="language-asm" data-lang="asm"><span class="err">0</span><span class="nf">x080498AE</span>       <span class="mi">83</span> <span class="no">EC</span> <span class="mi">04</span>            <span class="no">sub</span>     <span class="no">esp</span><span class="p">,</span> <span class="mi">4</span>
<span class="err">0</span><span class="nf">x080498B1</span>       <span class="mi">68</span> <span class="no">FE</span> <span class="no">CA</span> <span class="mi">00</span> <span class="mi">00</span>      <span class="no">push</span>    <span class="mi">0</span><span class="no">CAFEh</span>
<span class="err">0</span><span class="nf">x080498B6</span>       <span class="mi">68</span> <span class="mi">37</span> <span class="mi">13</span> <span class="mi">00</span> <span class="mi">00</span>      <span class="no">push</span>    <span class="mi">1337</span><span class="no">h</span>
<span class="err">0</span><span class="nf">x080498BB</span>       <span class="mi">68</span> <span class="mi">2</span><span class="no">A</span> <span class="no">DB</span> <span class="mi">85</span> <span class="mi">7</span><span class="no">E</span>      <span class="no">push</span>    <span class="mi">7</span><span class="no">E85DB2Ah</span>
<span class="err">0</span><span class="nf">x080498C0</span>       <span class="mi">8</span><span class="no">B</span> <span class="mi">45</span> <span class="no">D8</span>            <span class="no">mov</span>     <span class="no">eax</span><span class="p">,</span> <span class="p">[</span><span class="no">ebp</span><span class="err">+</span><span class="no">zeroValueException</span><span class="p">]</span>
<span class="err">0</span><span class="nf">x080498C3</span>       <span class="no">FF</span> <span class="no">D0</span>               <span class="no">call</span>    <span class="no">eax</span>
<span class="err">0</span><span class="nf">x080498C5</span>       <span class="mi">83</span> <span class="no">C4</span> <span class="mi">10</span>            <span class="no">add</span>     <span class="no">esp</span><span class="p">,</span> <span class="mi">10</span><span class="no">h</span>
</code></pre></div><p>As we learned earlier, the <code>call eax</code> instruction will trigger <code>SIGSEGV</code> that will be caught by <em>child2</em>. Looking at the handler in <em>child2</em>, we can see that the operation it performs is very simple. It only moves a hardcoded value <code>0x9E3779B9</code> to the <code>eax</code> register of <em>child1</em>.</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="k">case</span> <span class="mh">0x7E85DB2A</span><span class="o">:</span>                  <span class="c1">// Pushed at 0x080498BB
</span><span class="c1"></span>    <span class="n">child1_regs</span><span class="p">.</span><span class="n">eax</span> <span class="o">=</span> <span class="mh">0x9E3779B9</span><span class="p">;</span>
</code></pre></div><h3 id="theory">Theory</h3>
<p>Seeing this, we can&rsquo;t help but wonder what prevents us from replacing the sequence of instructions from <code>0x080498AE</code> to <code>0x080498C5</code> with <code>nop</code> operations and a single <code>mov eax, 0x9E3779B9</code>. After all, we can easily replace the bytes of the snippet above from <em>child1</em> <code>83 EC 04 68 FE CA 00 00 68 37 13 00 00 68 2A DB 85 7E 8B 45 D8 FF D0 83 C4 10</code> with these bytes:</p>
<div class="highlight"><pre class="chroma"><code class="language-asm" data-lang="asm"><span class="err">90</span>              <span class="c">; nop
</span><span class="c"></span><span class="err">90</span>              <span class="c">; nop
</span><span class="c"></span><span class="err">90</span>              <span class="c">; nop
</span><span class="c"></span><span class="nf">B8</span> <span class="no">B9</span> <span class="mi">79</span> <span class="mi">37</span> <span class="mi">9</span><span class="no">E</span>  <span class="c">; mov    eax, 0x9e3779b9
</span><span class="c"></span><span class="mi">90</span>              <span class="c">; nop
</span><span class="c"></span><span class="mi">90</span>              <span class="c">; nop
</span><span class="c"></span><span class="mi">90</span>              <span class="c">; nop
</span><span class="c"></span><span class="mi">90</span>              <span class="c">; nop
</span><span class="c"></span><span class="no">...</span>
</code></pre></div><p>Easy, right? Not only that it is possible for this example, it is actually possible for all the handlers in child2 — they all fit in a simple patch. There are several ways we can patch the binary.</p>
<h3 id="classic-patching"><strong>Classic Patching</strong></h3>
<p>The first one is the classic patch. Using the classic patching method, we need to search for the places we want to patch and replace the original bytes with <code>nop</code> instructions and the x86 instructions that can provide us the same functionality as <em>child2</em>. Such patching can be done straight from IDA, or from any other hex editor. Simple, find the sequence of bytes, and patch it.</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="kn">from</span> <span class="nn">malduck</span> <span class="kn">import</span> <span class="n">unhex</span> 
<span class="n">end_addr</span> <span class="o">=</span> <span class="n">idc</span><span class="o">.</span><span class="n">get_segm_end</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="c1"># Find the sequence of bytes to patch</span>
<span class="n">offset</span> <span class="o">=</span> <span class="n">ida_search</span><span class="o">.</span><span class="n">find_binary</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">end_addr</span><span class="p">,</span><span class="s2">&#34;83 EC 04 68 FE CA 00 00 68 37 13 00 00 68 2A DB 85 7E 8B 45 D8 FF D0 83 C4 10&#34;</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="n">idc</span><span class="o">.</span><span class="n">SEARCH_DOWN</span><span class="p">)</span>
<span class="c1"># Patch them</span>
<span class="n">ida_bytes</span><span class="o">.</span><span class="n">patch_bytes</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span><span class="n">unhex</span><span class="p">(</span><span class="s2">&#34;909090B8B979379E909090909090909090909090909090909090&#34;</span><span class="p">))</span>
</code></pre></div><h3 id="emulation"><strong>Emulation</strong></h3>
<p>The second approach is fancier and doesn&rsquo;t require us to go and write assembly byte codes by ourselves. In this approach, we set a conditional breakpoint at the top instruction that we want to skip. In the conditional breakpoint, we put a Python or IDC script that will manipulate the registers in an equivalent manner to what <em>child2</em> is done. Finally, we will change the instruction pointer register, <code>EIP</code>, to the point after the <code>call</code> to <code>eax</code>. If we will take the previous example, we will have to put a conditional breakpoint at <code>0x080498AE</code> and use the following Python code:</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="c1"># We set the value of eax</span>
<span class="n">set_reg_value</span><span class="p">(</span><span class="mh">0x9E3779B9</span><span class="p">,</span><span class="s2">&#34;eax&#34;</span><span class="p">)</span>

<span class="c1"># Move eip 26 bytes forward</span>
<span class="n">eip</span><span class="o">=</span><span class="n">get_reg_value</span><span class="p">(</span><span class="s2">&#34;eip&#34;</span><span class="p">)</span>
<span class="n">set_reg_value</span><span class="p">(</span><span class="n">eip</span><span class="o">+</span><span class="mh">0x1a</span><span class="p">,</span><span class="s2">&#34;eip&#34;</span><span class="p">)</span>
</code></pre></div><p>Setting such a conditional breakpoint in IDA is very useful since whenever they will hit, the Python script will be triggered and perform the register manipulations. For many of us, writing Python is easier. That said, this approach will only work while in debug sessions from IDA, which makes it less flexible. For other debuggers, you can use the same method with the API provided by them.</p>
<p>For the sake of this article, we will use the classic patching method as it is easier for the readers to apply it to their favorite platforms and debuggers.</p>
<h3 id="overcoming-fork">Overcoming Fork</h3>
<p>Patching the parts that transfer control to <em>child2</em> isn&rsquo;t enough to allow us to debug <em>child1.</em> This is because <em>child1</em> forks itself so <em>child2</em> can debug it. If we want to debug <em>child1</em>, without losing functionality, we must overcome this <code>fork</code> and prevent <em>child2</em> from being born. Thankfully, it is quite simple as all we need to do is to patch the part in <em>child1</em> that is responsible for the <code>fork</code>.</p>
<a class="lightgallery" href="/posts/flare-on-7-break/images/image_8.png" title="/posts/flare-on-7-break/images/image_8.png" data-thumbnail="/posts/flare-on-7-break/images/image_8.png">
        <img
            class="lazyload"
            src="/svg/loading.min.svg"
            data-src="images/image_8.png"
            data-srcset="/posts/flare-on-7-break/images/image_8.png, images/image_8.png 1.5x, /posts/flare-on-7-break/images/image_8.png 2x"
            data-sizes="auto"
            alt="/posts/flare-on-7-break/images/image_8.png" />
    </a>
<p>To do this, we can <code>nop</code> everything from <code>0x8049137</code> until <code>0x804915A</code> which is the instruction <code>add esp, 10h</code> after the call to the second <code>fork</code>. Now, the program can run and function correctly without <em>child2</em>.</p>
<h3 id="patching-child1">Patching <em>child1</em></h3>
<p>Now that we are aware to all the patches we need to do, we can quickly write an IDA Python script that does the work for us.</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="kn">from</span> <span class="nn">malduck</span> <span class="kn">import</span> <span class="n">unhex</span> 

<span class="n">end_addr</span> <span class="o">=</span> <span class="n">idc</span><span class="o">.</span><span class="n">get_segm_end</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

<span class="n">offset</span> <span class="o">=</span> <span class="n">ida_search</span><span class="o">.</span><span class="n">find_binary</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">end_addr</span><span class="p">,</span><span class="s2">&#34;83 EC 04 52 50 68 24 3C 2D B8 8B 45 D8 FF D0 83 C4 10&#34;</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="n">idc</span><span class="o">.</span><span class="n">SEARCH_DOWN</span><span class="p">)</span>
<span class="c1"># inc    eax</span>
<span class="n">ida_bytes</span><span class="o">.</span><span class="n">patch_bytes</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span><span class="n">unhex</span><span class="p">(</span><span class="s2">&#34;909090409090909090909090909090909090&#34;</span><span class="p">))</span>

<span class="n">offset</span> <span class="o">=</span> <span class="n">ida_search</span><span class="o">.</span><span class="n">find_binary</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">end_addr</span><span class="p">,</span><span class="s2">&#34;83 EC 04 68 FE CA 00 00 68 37 13 00 00 68 2A DB 85 7E 8B 45 D8 FF D0 83 C4 10&#34;</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="n">idc</span><span class="o">.</span><span class="n">SEARCH_DOWN</span><span class="p">)</span>
<span class="c1"># mov    eax,0x9e3779b9</span>
<span class="n">ida_bytes</span><span class="o">.</span><span class="n">patch_bytes</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span><span class="n">unhex</span><span class="p">(</span><span class="s2">&#34;909090B8B979379E909090909090909090909090909090909090&#34;</span><span class="p">))</span>

<span class="n">offset</span> <span class="o">=</span> <span class="n">ida_search</span><span class="o">.</span><span class="n">find_binary</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">end_addr</span><span class="p">,</span><span class="s2">&#34;83 EC 04 52 50 68 2C 10 4E 6B 8B 45 F0 FF D0 83 C4 10&#34;</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="n">idc</span><span class="o">.</span><span class="n">SEARCH_DOWN</span><span class="p">)</span>
<span class="c1"># add    eax,edx</span>
<span class="n">ida_bytes</span><span class="o">.</span><span class="n">patch_bytes</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span><span class="n">unhex</span><span class="p">(</span><span class="s2">&#34;90909001D090909090909090909090909090&#34;</span><span class="p">))</span>

<span class="n">offset</span> <span class="o">=</span> <span class="n">ida_search</span><span class="o">.</span><span class="n">find_binary</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">end_addr</span><span class="p">,</span><span class="s2">&#34;83 EC 04 52 50 68 2E 45 16 58 8B 45 F0 FF D0 83 c4 10&#34;</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="n">idc</span><span class="o">.</span><span class="n">SEARCH_DOWN</span><span class="p">)</span>
<span class="c1"># push   edx</span>
<span class="c1"># push   eax</span>
<span class="c1"># call   0xffffff86</span>
<span class="n">ida_bytes</span><span class="o">.</span><span class="n">patch_bytes</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span><span class="n">unhex</span><span class="p">(</span><span class="s2">&#34;9090905250E87CFFFFFF909090909083C408&#34;</span><span class="p">))</span>

<span class="n">offset</span> <span class="o">=</span> <span class="n">ida_search</span><span class="o">.</span><span class="n">find_binary</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">end_addr</span><span class="p">,</span><span class="s2">&#34;83 EC 04 52 50 68 30 7A DE 44 8B 45 F0 FF D0 83 C4 10&#34;</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="n">idc</span><span class="o">.</span><span class="n">SEARCH_DOWN</span><span class="p">)</span>
<span class="c1"># xor    eax,edx</span>
<span class="n">ida_bytes</span><span class="o">.</span><span class="n">patch_bytes</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span><span class="n">unhex</span><span class="p">(</span><span class="s2">&#34;90909031D090909090909090909090909090&#34;</span><span class="p">))</span>

<span class="n">offset</span> <span class="o">=</span> <span class="n">ida_search</span><span class="o">.</span><span class="n">find_binary</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">end_addr</span><span class="p">,</span><span class="s2">&#34;83 EC 04 52 50 68 28 A6 BD 91 8B 85 2C FF FF FF FF D0 83 C4 10&#34;</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="n">idc</span><span class="o">.</span><span class="n">SEARCH_DOWN</span><span class="p">)</span>
<span class="c1"># dec    eax</span>
<span class="c1"># shl    eax,0x4</span>
<span class="c1"># dec    edx</span>
<span class="c1"># and    edx,0xf</span>
<span class="c1"># or     eax,edx</span>
<span class="n">ida_bytes</span><span class="o">.</span><span class="n">patch_bytes</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span><span class="n">unhex</span><span class="p">(</span><span class="s2">&#34;48C1E0044A83E20F09D09090909090909090909090&#34;</span><span class="p">))</span>

<span class="n">offset</span> <span class="o">=</span> <span class="n">ida_search</span><span class="o">.</span><span class="n">find_binary</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">end_addr</span><span class="p">,</span><span class="s2">&#34;83 EC 08 68 80 90 04 08 6A 0E E8 8A F8 FF FF 83 C4 10 E8 E2 F8 FF FF 83 EC 0C 50 E8 5D 0F 00 00 83 C4 10&#34;</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="n">idc</span><span class="o">.</span><span class="n">SEARCH_DOWN</span><span class="p">)</span>
<span class="c1"># Fill the second fork with nops</span>
<span class="n">ida_bytes</span><span class="o">.</span><span class="n">patch_bytes</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span><span class="n">unhex</span><span class="p">(</span><span class="s2">&#34;9090909090909090909090909090909090909090909090909090909090909090909090&#34;</span><span class="p">))</span>
</code></pre></div><p>To apply the patches to the original binary, we can go to Edit → Patch program → Apply patches to input file.</p>
<p>Now that we made the patches, we want to be able to attach a debugger to the patched program. Naturally, we still have <em>child1</em> that debugs the parent process, and this means that we can not start our debugging session from the parent. Instead, we&rsquo;d want to attach IDA debugger to <em>child1</em> before it starts the important operations. To do this, we can utilize a very nice trick in x86 that causes the program to loop infinitely. The trick is to use the pair of bytes <code>EB FE</code> that will cause the program to jump to the current location. To use it, we can change our last patch in the screen above, and place <code>EB FE</code> inside. When the program will reach these bytes, it will &ldquo;wait&rdquo; for us to attach our debugger to it. When attached, we can simply change our instruction pointer to one of the <code>nop</code> instructions after the infinite loop, and we can debug the program step by step.</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">offset</span> <span class="o">=</span> <span class="n">ida_search</span><span class="o">.</span><span class="n">find_binary</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">end_addr</span><span class="p">,</span><span class="s2">&#34;83 EC 08 68 80 90 04 08 6A 0E E8 8A F8 FF FF 83 C4 10 E8 E2 F8 FF FF 83 EC 0C 50 E8 5D 0F 00 00 83 C4 10&#34;</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="n">idc</span><span class="o">.</span><span class="n">SEARCH_DOWN</span><span class="p">)</span>
<span class="c1"># Fill the second fork with EB FE (infinte loop) followed by nops</span>
<span class="n">ida_bytes</span><span class="o">.</span><span class="n">patch_bytes</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span><span class="n">unhex</span><span class="p">(</span><span class="s2">&#34;EBFE909090909090909090909090909090909090909090909090909090909090909090&#34;</span><span class="p">))</span><span class="err">`</span>
</code></pre></div><p>This is how IDA shows the infinite loop of <code>EB FE</code>.</p>
<a class="lightgallery" href="/posts/flare-on-7-break/images/image_9.png" title="/posts/flare-on-7-break/images/image_9.png" data-thumbnail="/posts/flare-on-7-break/images/image_9.png">
        <img
            class="lazyload"
            src="/svg/loading.min.svg"
            data-src="images/image_9.png"
            data-srcset="/posts/flare-on-7-break/images/image_9.png, images/image_9.png 1.5x, /posts/flare-on-7-break/images/image_9.png 2x"
            data-sizes="auto"
            alt="/posts/flare-on-7-break/images/image_9.png" />
    </a>
<p>Having the ability to debug the program will make the analysis easier, but since the goal of the write-up is to thoroughly explain the flow of the challenge, and because many of our readers did not use a similar patching method, we will still keep the &ldquo;<em>child1</em>&rdquo; and &ldquo;<em>child2</em>&rdquo; terminology.</p>
<h2 id="decrypting-the-strings">Decrypting the Strings</h2>
<p>Let&rsquo;s back and focus on the magic number we saw being used by <em>child1</em> which is <code>0x91BDA628</code>. The simple arithmetic operation will use our two arguments and store the result in <code>eax</code> of <em>child1</em>. After doing the work based on the magic number, <em>child2</em> will make <em>child1</em> perform a <code>ret</code> — it&rsquo;ll set its <code>eip</code> to the return address, add 4 to the stack pointer, set its registers, and continue its execution using <code>PTRACE_CONT</code>.</p>
<p>Now we know what this calling of address 0 is doing, and we can quickly use python to try and decrypt a string and see if our understanding is indeed correct.</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">decrypt_odd</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
    <span class="n">dec</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="mi">2</span><span class="p">):</span>
        <span class="n">dec</span><span class="o">.</span><span class="n">append</span><span class="p">(((</span><span class="mh">0x10</span> <span class="o">*</span> <span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">|</span> <span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">)</span>
    <span class="k">return</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">chr</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">dec</span><span class="p">])</span>

<span class="n">decrypt_odd</span><span class="p">(</span><span class="sa">b</span><span class="s2">&#34;FEHCGBGDGFHCFAGJGEDKCACFGEAA&#34;</span><span class="p">)</span>

<span class="c1"># Results:</span>
<span class="c1"># &#39;TracerPid: %d\x00&#39;</span>
</code></pre></div><p>Looks like it worked!</p>
<div class="details admonition tip open">
        <div class="details-summary admonition-title">
            <i class="icon fas fa-lightbulb fa-fw"></i>Tip<i class="details-icon fas fa-angle-right fa-fw"></i>
        </div>
        <div class="details-content">
            <div class="admonition-content">Doing a lot of reverse engineering (and especially malware analysis and CTFs), you often find yourself in the need of identifying what type of encryption algorithms are being used in the code you analyze. There is a great IDA Pro plugin for that - <a href="https://github.com/polymorf/findcrypt-yara" target="_blank" rel="noopener noreffer">FindCrypt</a>. This plugin simply runs a lot of YARA rules against the code you&rsquo;re analyzing, trying to identify cryptographic constants and byte patterns, to eventually link them to a known encryption algorithm. To use this, just hit <code>Ctrl+Alt+F</code> and FindCrypt will rename and show you all the crypto constants within the binary.</div>
        </div>
    </div>
<p>Now, let&rsquo;s move on to the odd strings decryption.</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">v4</span> <span class="o">=</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">string_array</span><span class="p">)[</span><span class="n">index</span><span class="p">];</span>
<span class="n">sub_804A372</span><span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="n">v9</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">v4</span><span class="p">);</span>
<span class="n">dest</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="o">*</span><span class="p">((</span><span class="n">_DWORD</span> <span class="o">*</span><span class="p">)</span><span class="n">v4</span> <span class="o">+</span> <span class="mi">4</span><span class="p">));</span>
<span class="n">memcpy</span><span class="p">(</span><span class="n">dest</span><span class="p">,</span> <span class="n">v4</span> <span class="o">+</span> <span class="mi">20</span><span class="p">,</span> <span class="o">*</span><span class="p">((</span><span class="n">_DWORD</span> <span class="o">*</span><span class="p">)</span><span class="n">v4</span> <span class="o">+</span> <span class="mi">4</span><span class="p">));</span>
<span class="k">for</span> <span class="p">(</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="o">*</span><span class="p">((</span><span class="n">_DWORD</span> <span class="o">*</span><span class="p">)</span><span class="n">v4</span> <span class="o">+</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">j</span><span class="p">;</span> <span class="n">j</span> <span class="o">+=</span> <span class="mi">16</span> <span class="p">)</span>
  <span class="n">sub_804B228</span><span class="p">(</span><span class="n">v9</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dest</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">dest</span><span class="p">;</span>
</code></pre></div><p>We see that <code>sub_804A372</code> is being called with the start of the decrypted string/data, then a new buffer for the result is being allocated with a DWORD size that is read from the 5th DWORD in the decrypted data, and finally, there is a loop that iterates the data starting from the 6th DWORD, in 16 bytes blocks and (probably) decrypts each block using <code>sub_804B228</code>. Taking a quick peek at <code>sub_804A372</code>, we see it simply wraps <code>sub_804A11A</code>. Looking at these functions, we notice that FindCrypt helped us identify a <code>RijnDael_AES_LONG</code> constant that suggests that maybe this decryption of odd indexed strings is simply generic AES. If we weren&rsquo;t using FindCrypt, we could have simply gone to the actual byte array and search for the values to see if it contains some known crypto constants.</p>
<a class="lightgallery" href="/posts/flare-on-7-break/images/image_10.png" title="/posts/flare-on-7-break/images/image_10.png" data-thumbnail="/posts/flare-on-7-break/images/image_10.png">
        <img
            class="lazyload"
            src="/svg/loading.min.svg"
            data-src="images/image_10.png"
            data-srcset="/posts/flare-on-7-break/images/image_10.png, images/image_10.png 1.5x, /posts/flare-on-7-break/images/image_10.png 2x"
            data-sizes="auto"
            alt="/posts/flare-on-7-break/images/image_10.png" />
    </a>
<p>We would get Rijndael in the first search result:</p>
<a class="lightgallery" href="/posts/flare-on-7-break/images/image_11.png" title="/posts/flare-on-7-break/images/image_11.png" data-thumbnail="/posts/flare-on-7-break/images/image_11.png">
        <img
            class="lazyload"
            src="/svg/loading.min.svg"
            data-src="images/image_11.png"
            data-srcset="/posts/flare-on-7-break/images/image_11.png, images/image_11.png 1.5x, /posts/flare-on-7-break/images/image_11.png 2x"
            data-sizes="auto"
            alt="/posts/flare-on-7-break/images/image_11.png" />
    </a>
<p>Now when that&rsquo;s out of the way, we have two options:</p>
<ol>
<li>Understand exactly how AES is implemented here, and figure out if that&rsquo;s a classic implementation</li>
<li>Assume this is a normal implementation, and try to decrypt the data we see</li>
</ol>
<p>If you really need to understand how this binary works, option 1 will probably be your go-to, in this case, it&rsquo;s always good to have a look at a simple source code implementation of AES, like <a href="https://github.com/kokke/tiny-AES-c" target="_blank" rel="noopener noreffer">this one</a>. However, since we&rsquo;re in a CTF and all we want from this binary is our precious flag, it&rsquo;ll probably be more efficient to go with option 2.</p>
<p>From the decryption code we saw before, we know that the size of the encrypted data is probably at offset 16 (based on the allocation and the decryption loop). Another thing we can assume is that the actual encrypted data starts right after the size, at offset 20 (based on the <code>memcpy</code> to the new buffer). So it&rsquo;ll be reasonable to assume that the key to our encrypted data is in the first 16 bytes (offset 0) of the data. Let&rsquo;s put that to the test and try to decrypt the string that this function returns if passed <code>0xB8</code> as the argument.</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="kn">from</span> <span class="nn">malduck</span> <span class="kn">import</span> <span class="n">unhex</span><span class="p">,</span> <span class="n">aes</span>

<span class="c1"># 0xB8 ^ 0xAA results with 18 and will be the index in the strings array</span>
<span class="nb">bytes</span> <span class="o">=</span> <span class="n">unhex</span><span class="p">(</span><span class="s2">&#34;62F0084EFFD0F3E99C3E8EAC5C1468B720000000C6F267D8795D510BA500FDA48CFF7F331F819E5EAA57E0FD29F2D416715F9EC2&#34;</span><span class="p">)</span>

<span class="n">key</span> <span class="o">=</span> <span class="nb">bytes</span><span class="p">[:</span><span class="mi">16</span><span class="p">]</span>
<span class="n">size</span> <span class="o">=</span> <span class="nb">bytes</span><span class="p">[</span><span class="mi">16</span><span class="p">:</span><span class="mi">20</span><span class="p">]</span>
<span class="n">data</span> <span class="o">=</span> <span class="nb">bytes</span><span class="p">[</span><span class="mi">20</span><span class="p">:]</span>
<span class="n">aes</span><span class="o">.</span><span class="n">ecb</span><span class="o">.</span><span class="n">decrypt</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>

<span class="c1"># Results:</span>
<span class="c1"># b&#39;sorry i stole your input :)\x00\x00\x00\x00\x00&#39;</span>
</code></pre></div><p>Turns out we were right. Now we also understand where the &lsquo;sorry i stole your input :)&rsquo; output comes from (remember that <em>child1</em> writes this string to the <code>input_buffer</code> in <em>parent)</em>.</p>
<h2 id="understanding-the-first-check">Understanding the First Check</h2>
<p>Let us now regroup, and come back to <em>parent</em>&rsquo;s <code>main</code>:</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="kr">__cdecl</span> <span class="n">__noreturn</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">puts</span><span class="p">(</span><span class="s">&#34;welcome to the land of sunshine and rainbows!&#34;</span><span class="p">);</span>
  <span class="n">puts</span><span class="p">(</span><span class="s">&#34;as a reward for getting this far in FLARE-ON, we&#39;ve decided to make this one soooper easy&#34;</span><span class="p">);</span>
  <span class="n">putchar</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&#34;please enter a password friend :) &#34;</span><span class="p">);</span>
  <span class="n">buf</span><span class="p">[</span><span class="n">read</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="mh">0xFFu</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span> <span class="n">check_input</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span> <span class="p">)</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;hooray! the flag is: %s</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
  <span class="k">else</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;sorry, but &#39;%s&#39; is not correct</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
  <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>The next thing that happens here is the call to the <code>check_input</code> function. Since <em>child1</em> changed the first bytes in the code of <code>check_input</code>, <em>parent</em>&rsquo;s invocation of this function will execute an illegal instruction (<code>0xB0F</code>) and a <code>SIGILL</code> will be sent to <em>child1</em>. If we look at the rest of <code>child1_main</code> we&rsquo;ll see the code responsible for handling this signal.</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">if</span> <span class="p">(</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="mh">0xFF00</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span> <span class="o">==</span> <span class="n">SIGILL</span> <span class="p">)</span>
<span class="p">{</span>
  <span class="n">input_len</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">input_buffer</span><span class="p">);</span>
  <span class="n">copy_to_pid</span><span class="p">(</span><span class="n">parent_pid</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">input_buffer</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span><span class="n">input_buffer</span><span class="p">,</span> <span class="n">input_len</span><span class="p">);</span>
  <span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_GETREGS</span><span class="p">,</span> <span class="n">parent_pid</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">&amp;</span><span class="n">parent_regs</span><span class="p">);</span>
  <span class="n">parent_esp</span> <span class="o">=</span> <span class="n">parent_regs</span><span class="p">.</span><span class="n">esp</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span> <span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_POKEDATA</span><span class="p">,</span> <span class="n">parent_pid</span><span class="p">,</span> <span class="n">parent_regs</span><span class="p">.</span><span class="n">esp</span> <span class="o">+</span> <span class="mi">4</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">input_buffer</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="p">)</span>
    <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
  <span class="n">parent_regs</span><span class="p">.</span><span class="n">eip</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">sub_8048DCB</span><span class="p">;</span>
  <span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_SETREGS</span><span class="p">,</span> <span class="n">parent_pid</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">&amp;</span><span class="n">parent_regs</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>What we have here is as follows:</p>
<ol>
<li><em>child1</em> copies the input of the user is read to the same address in <em>parent</em>&rsquo;s memory.</li>
<li><em>child1</em> sets the instruction pointer of <em>parent</em> to point to <code>sub_8048DCB1</code>, which we&rsquo;ll rename to <code>actual_check_input</code> since this code will be executed instead of <code>check_input</code>, and it will receive the same argument — the user&rsquo;s input.</li>
</ol>
<p>Our journey to the flag continues into <code>actual_check_input</code>.</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">int</span> <span class="kr">__cdecl</span> <span class="nf">actual_check_input</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">input_buffer</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">v5</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">input_buffer</span><span class="p">);</span>
  <span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#34;rm&#34;</span><span class="p">;</span>
  <span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#34;-rf&#34;</span><span class="p">;</span>
  <span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#34;--no-preserve-root&#34;</span><span class="p">;</span>
  <span class="n">argv</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#34;/&#34;</span><span class="p">;</span>
  <span class="n">argv</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">execve</span><span class="p">(</span><span class="n">input_buffer</span><span class="p">,</span> <span class="n">argv</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="o">--</span><span class="n">v5</span><span class="p">;</span>
  <span class="n">v4</span> <span class="o">=</span> <span class="o">-</span><span class="n">nice</span><span class="p">(</span><span class="mh">0xA5</span><span class="p">);</span>
  <span class="n">sub_804B495</span><span class="p">(</span><span class="n">v2</span><span class="p">,</span> <span class="n">v4</span><span class="p">);</span>
  <span class="n">sub_804BABC</span><span class="p">(</span><span class="n">v2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">unk_81A50EC</span><span class="p">);</span>
  <span class="n">sub_804BABC</span><span class="p">(</span><span class="n">v2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">unk_81A50F0</span><span class="p">);</span>
  <span class="n">sub_804BABC</span><span class="p">(</span><span class="n">v2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">unk_81A50F4</span><span class="p">);</span>
  <span class="n">sub_804BABC</span><span class="p">(</span><span class="n">v2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">unk_81A50F8</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="n">memcmp</span><span class="p">(</span><span class="n">input_buffer</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">unk_81A50EC</span><span class="p">,</span> <span class="mh">0x10u</span><span class="p">)</span> <span class="p">)</span>
  <span class="p">{</span>
    <span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">unk_81A50EC</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0x10u</span><span class="p">);</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">sub_8048F05</span><span class="p">(</span><span class="n">input_buffer</span> <span class="o">+</span> <span class="mi">16</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">else</span>
  <span class="p">{</span>
    <span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">unk_81A50EC</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0x10u</span><span class="p">);</span>
    <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>Here we see the best troll of this challenge - a call to <code>execve</code> with an <code>argv</code> pointing to <code>&quot;rm -rf --no-preserve-root /&quot;</code> which is quite disturbing on its own. Having said that, since we already know the mechanism at play here, we know that <em>child1</em> is going to receive control at this point, instead of <em>parent</em> really executing an <code>execve</code> syscall.</p>
<p>Let&rsquo;s calculate our correct magic number again, and locate the appropriate code path that will handle the <code>execve</code> syscall in <code>child1_main</code>:</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">Python</span><span class="o">&gt;</span> <span class="mh">0x1337CAFE</span> <span class="o">*</span> <span class="p">(</span><span class="mi">11</span> <span class="o">^</span> <span class="mh">0xDEADBEEF</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xffffffff</span> <span class="c1"># 11 == EXECVE</span>
<span class="mh">0xf7ff4e38</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">else</span> <span class="nf">if</span> <span class="p">(</span> <span class="n">magic</span> <span class="o">==</span> <span class="mh">0xF7FF4E38</span> <span class="p">)</span> <span class="c1">// execve
</span><span class="c1"></span><span class="p">{</span>
  <span class="n">buf</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mh">0x12Cu</span><span class="p">);</span>
  <span class="n">sub_804BCBE</span><span class="p">(</span><span class="n">parent_pid</span><span class="p">,</span> <span class="n">parent_regs</span><span class="p">.</span><span class="n">ebx</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">buf</span><span class="p">,</span> <span class="mi">300</span><span class="p">);</span>
  <span class="n">size</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">((</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">buf</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span> <span class="o">*</span><span class="p">((</span><span class="n">_BYTE</span> <span class="o">*</span><span class="p">)</span><span class="n">buf</span> <span class="o">+</span> <span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0xA</span> <span class="p">)</span>
    <span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_POKEDATA</span><span class="p">,</span> <span class="n">parent_pid</span><span class="p">,</span> <span class="n">parent_regs</span><span class="p">.</span><span class="n">ebx</span> <span class="o">+</span> <span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="n">free</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>These few lines of code allocate a local buffer and then copy the <code>input_buffer</code> from the <em>parent</em> (<code>ebx</code> holds the first syscall parameter, which is the pointer to the <code>input_buffer</code> in this case, and <code>sub_804BCBE</code> copies that data using <code>PTRACE_PEEKDATA</code> again). Then, <em>child1</em> will check whether the last character of the input is <code>0xA</code>(line feed) and will replace it with zero using <code>PTRACE_POKEDATA</code> in the <em>parent</em>. This means that the whole <code>execve</code> purpose here is to strip the user input. Oh well, let&rsquo;s continue to see which other syscalls <em>parent</em> will try to invoke.</p>
<p>After getting the scary <code>execve</code> out of our way, there&rsquo;s really one thing that&rsquo;s very interesting to anyone trying to get the flag - a <code>memcmp</code> with the <code>input_buffer</code>. If we could get our hands on the memory to which our input is being compared, we will surely get the flag or at least some of it. It looks like this memory which is at <code>unk_81A50EC</code>, is being modified by all those function calls before the <code>memcmp</code>, so of course, we can try and understand the logic, but a better option (this is a CTF mind you), is to simply examine this memory dynamically after it already got modified. But, as you already know, we can&rsquo;t really put a breakpoint at this point and look at the memory since this process is already being ptraced. We do, however, have 2 great option at our disposal:</p>
<ol>
<li>Patch the call. Make <code>parent</code> call <code>write</code> (or another function that&rsquo;ll output to the screen like <code>puts</code> for instance) with the memory we&rsquo;d like to see instead of <code>memcmp</code> and it will basically hand us the flag.</li>
<li>Hook <code>memcmp</code> to see what&rsquo;s in the two memory locations being compared.</li>
</ol>
<p>Both options will work, but we&rsquo;ll demonstrate option 1.</p>
<h2 id="patching-memcmp">Patching <em>memcmp</em></h2>
<p>First let&rsquo;s have a look at the assembly code of the call we&rsquo;d like to change.</p>
<div class="highlight"><pre class="chroma"><code class="language-asm" data-lang="asm"><span class="nl">.text:</span><span class="err">08048</span><span class="nf">EAC</span> <span class="mi">6</span><span class="no">A</span> <span class="mi">10</span>                <span class="no">push</span>    <span class="mi">10</span><span class="no">h</span>             <span class="c">; n
</span><span class="c"></span><span class="no">.text</span><span class="p">:</span><span class="mi">08048</span><span class="no">EAE</span> <span class="mi">68</span> <span class="no">EC</span> <span class="mi">50</span> <span class="mi">1</span><span class="no">A</span> <span class="mi">08</span>       <span class="no">push</span>    <span class="no">offset</span> <span class="no">unk_81A50EC</span> <span class="c">; s2
</span><span class="c"></span><span class="no">.text</span><span class="p">:</span><span class="mi">08048</span><span class="no">EB3</span> <span class="no">FF</span> <span class="mi">75</span> <span class="mi">08</span>             <span class="no">push</span>    <span class="p">[</span><span class="no">ebp</span><span class="err">+</span><span class="no">input_buffer</span><span class="p">]</span> <span class="c">; s1
</span><span class="c"></span><span class="no">.text</span><span class="p">:</span><span class="mi">08048</span><span class="no">EB6</span> <span class="no">E8</span> <span class="mi">25</span> <span class="no">FB</span> <span class="no">FF</span> <span class="no">FF</span>       <span class="no">call</span>    <span class="no">_memcmp</span>
</code></pre></div><p><code>E8</code> is a relative <a href="https://c9x.me/x86/html/file_module_x86_id_26.html" target="_blank" rel="noopener noreffer">call</a>, which means that in order to get to <code>memcmp</code> we&rsquo;ll jump from the address after the call instruction 0xfffffb25 bytes forward and we&rsquo;ll get to <code>0x080489E0</code>. In order to replace <code>memcmp</code> with <code>write</code>, we&rsquo;ll first get the address of our <code>_write</code> function from IDA (<code>0x08048AD0</code>), and then perform the following:</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">Python</span><span class="o">&gt;</span><span class="kn">from</span> <span class="nn">malduck</span> <span class="kn">import</span> <span class="n">p32</span>
<span class="n">Python</span><span class="o">&gt;</span><span class="n">ida_bytes</span><span class="o">.</span><span class="n">patch_bytes</span><span class="p">(</span><span class="mh">0x08048EB6</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">p32</span><span class="p">(</span><span class="mh">0x08048AD0</span> <span class="o">-</span> <span class="n">here</span><span class="p">()</span> <span class="o">-</span><span class="mi">5</span><span class="p">))</span>
</code></pre></div><p>What we pass to <code>patch_bytes</code> is first the address of bytes we&rsquo;d like to patch, which is the address of the value of our relative call (right after the <code>E8</code>) and then the actual bytes which we calculate based on our current location and the location of <code>_write</code> (we subtract 5 since the size of the entire call instruction is 5 bytes). Et voila:</p>
<div class="highlight"><pre class="chroma"><code class="language-asm" data-lang="asm"><span class="nl">.text:</span><span class="err">08048</span><span class="nf">EA6</span> <span class="mi">83</span> <span class="no">C4</span> <span class="mi">10</span>             <span class="no">add</span>     <span class="no">esp</span><span class="p">,</span> <span class="mi">10</span><span class="no">h</span>
<span class="nl">.text:</span><span class="err">08048</span><span class="nf">EA9</span> <span class="mi">83</span> <span class="no">EC</span> <span class="mi">04</span>             <span class="no">sub</span>     <span class="no">esp</span><span class="p">,</span> <span class="mi">4</span>
<span class="nl">.text:</span><span class="err">08048</span><span class="nf">EAC</span> <span class="mi">6</span><span class="no">A</span> <span class="mi">10</span>                <span class="no">push</span>    <span class="mi">10</span><span class="no">h</span>             <span class="c">; n
</span><span class="c"></span><span class="no">.text</span><span class="p">:</span><span class="mi">08048</span><span class="no">EAE</span> <span class="mi">68</span> <span class="no">EC</span> <span class="mi">50</span> <span class="mi">1</span><span class="no">A</span> <span class="mi">08</span>       <span class="no">push</span>    <span class="no">offset</span> <span class="no">unk_81A50EC</span> <span class="c">; s2
</span><span class="c"></span><span class="no">.text</span><span class="p">:</span><span class="mi">08048</span><span class="no">EB3</span> <span class="no">FF</span> <span class="mi">75</span> <span class="mi">08</span>             <span class="no">push</span>    <span class="p">[</span><span class="no">ebp</span><span class="err">+</span><span class="no">input_buffer</span><span class="p">]</span> <span class="c">; s1
</span><span class="c"></span><span class="no">.text</span><span class="p">:</span><span class="mi">08048</span><span class="no">EB6</span> <span class="no">E8</span> <span class="mi">15</span> <span class="no">FC</span> <span class="no">FF</span> <span class="no">FF</span>       <span class="no">call</span>    <span class="no">_write</span>
</code></pre></div><p>Then, we&rsquo;d like to change the first argument so it&rsquo;ll write our bytes to STDOUT. With our cursor on the last push (1st argument), we&rsquo;ll go to <em>Edit→Patch program→Assemble&hellip;</em> and we&rsquo;ll change the instruction to <code>push 1</code>.</p>
<a class="lightgallery" href="/posts/flare-on-7-break/images/image_12.png" title="/posts/flare-on-7-break/images/image_12.png" data-thumbnail="/posts/flare-on-7-break/images/image_12.png">
        <img
            class="lazyload"
            src="/svg/loading.min.svg"
            data-src="images/image_12.png"
            data-srcset="/posts/flare-on-7-break/images/image_12.png, images/image_12.png 1.5x, /posts/flare-on-7-break/images/image_12.png 2x"
            data-sizes="auto"
            alt="/posts/flare-on-7-break/images/image_12.png" />
    </a>
<p>Now we&rsquo;ll just patch the actual binary by going to <em>Edit→Patch Program→Apply patches to input file&hellip;</em> and execute. We get:</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ ./break-patched
welcome to the land of sunshine and rainbows!
as a reward <span class="k">for</span> getting this far in FLARE-ON, we<span class="s1">&#39;ve decided to make this one soooper easy
</span><span class="s1">
</span><span class="s1">please enter a password friend :) oh
</span><span class="s1">w3lc0mE_t0_Th3_lsorry, but &#39;</span>sorry i stole your input :<span class="o">)</span><span class="err">&#39;</span> is not correct
</code></pre></div><p>The start of the flag is <code>w3lc0mE_t0_Th3_l</code>!</p>
<h1 id="stage-2">Stage 2</h1>
<h2 id="analyzing-the-second-check">Analyzing the Second Check</h2>
<p>Since we only got part of the flag, let&rsquo;s continue analyzing what happens in our <code>actual_check_input</code> function, executed by the <em>parent</em>.</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="n">memcmp</span><span class="p">(</span><span class="n">input_buffer</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">unk_81A50EC</span><span class="p">,</span> <span class="mh">0x10u</span><span class="p">)</span> <span class="p">)</span>
<span class="p">{</span>
  <span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">unk_81A50EC</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0x10u</span><span class="p">);</span>
  <span class="n">result</span> <span class="o">=</span> <span class="n">sub_8048F05</span><span class="p">(</span><span class="n">input_buffer</span> <span class="o">+</span> <span class="mi">16</span><span class="p">);</span>
</code></pre></div><p>If we indeed insert the correct 16 bytes of the flag, <em>parent</em> will call <code>sub_8048F05</code> and pass the rest of our input into it, probably for validation. It&rsquo;s only natural that we&rsquo;ll rename this function as <code>check_rest_input</code>.</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">_BOOL4</span> <span class="kr">__cdecl</span> <span class="nf">check_rest_input</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">rest_input_buffer</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">s</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">-</span><span class="n">nice</span><span class="p">(</span><span class="mh">0xA4</span><span class="p">);</span>
  <span class="n">v1</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
  <span class="n">v5</span> <span class="o">=</span> <span class="n">sub_804BFED</span><span class="p">(</span><span class="mi">0LL</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">s</span><span class="p">,</span> <span class="n">v1</span><span class="p">);</span>
  <span class="n">v4</span> <span class="o">=</span> <span class="mi">40000</span><span class="p">;</span>
  <span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">file</span><span class="p">,</span> <span class="n">rest_input_buffer</span><span class="p">,</span> <span class="mh">0x20u</span><span class="p">);</span>
  <span class="k">for</span> <span class="p">(</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">v4</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">8</span> <span class="p">)</span>
    <span class="n">sub_804C369</span><span class="p">((</span><span class="n">__mode_t</span> <span class="o">*</span><span class="p">)(</span><span class="o">&amp;</span><span class="n">file</span> <span class="o">+</span> <span class="n">i</span><span class="p">),</span> <span class="n">v5</span><span class="p">,</span> <span class="n">SHIDWORD</span><span class="p">(</span><span class="n">v5</span><span class="p">),</span> <span class="n">v3</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">truncate</span><span class="p">(</span><span class="o">&amp;</span><span class="n">file</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span> <span class="o">==</span> <span class="mi">32</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>This function seems quite simple at first glance, but as we learned already - there&rsquo;s more to this challenge than meets the eye.</p>
<p>At a high-level view, this seems like another decryption routine, that iterates over 8-byte blocks this time. We also see some glibc functions that don&rsquo;t seem to make much sense in this context like <code>nice</code> and <code>truncate</code>, but as we saw before with <code>execve</code>, <em>child1</em> might alter their behavior altogether. As opposed to the previous part we solved, here we don&rsquo;t have any clear comparison of two memory areas, one containing our input and the other the desired result, so we&rsquo;d like to dig a little deeper to see how the syscalls in every glibc function here behave.</p>
<h3 id="understanding-nice">Understanding <em>nice</em></h3>
<p>The <a href="https://man7.org/linux/man-pages/man2/nice.2.html" target="_blank" rel="noopener noreffer">nice</a> function in Linux can change the priority of the calling thread. Looking at its usage here, it seems like the code expects <code>nice</code> to return a string pointer, which we&rsquo;d like to keep in mind while analyzing the next part.</p>
<p>It&rsquo;s a good idea to look at the <a href="https://code.woboq.org/userspace/glibc/sysdeps/posix/nice.c.html" target="_blank" rel="noopener noreffer">source code</a> of <code>nice</code>, so we can see exactly which syscalls are invoked by this function.</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">int</span> <span class="nf">nice</span> <span class="p">(</span><span class="kt">int</span> <span class="n">incr</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">save</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">prio</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">result</span><span class="p">;</span>
  <span class="cm">/* -1 is a valid priority, so we use errno to check for an error.  */</span>
  <span class="n">save</span> <span class="o">=</span> <span class="n">errno</span><span class="p">;</span>
  <span class="n">__set_errno</span> <span class="p">(</span><span class="mi">0</span><span class="p">);</span>
  <span class="n">prio</span> <span class="o">=</span> <span class="o">**</span><span class="n">__getpriority</span><span class="o">**</span> <span class="p">(</span><span class="n">PRIO_PROCESS</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">prio</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">errno</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="n">result</span> <span class="o">=</span> <span class="o">**</span><span class="n">__setpriority</span><span class="o">**</span> <span class="p">(</span><span class="n">PRIO_PROCESS</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">prio</span> <span class="o">+</span> <span class="n">incr</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">errno</span> <span class="o">==</span> <span class="n">EACCES</span><span class="p">)</span>
        <span class="n">__set_errno</span> <span class="p">(</span><span class="n">EPERM</span><span class="p">);</span>
      <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="n">__set_errno</span> <span class="p">(</span><span class="n">save</span><span class="p">);</span>
  <span class="k">return</span> <span class="o">**</span><span class="n">__getpriority</span><span class="o">**</span> <span class="p">(</span><span class="n">PRIO_PROCESS</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>3 syscalls are invoked here - <code>getpriority</code>, <code>setpriority</code>, and finally <code>getpriority</code> once more. Let us calculate the magic value for each system call and locate an appropriate code in <em>child1</em> that handles this syscall.</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">else</span> <span class="nf">if</span> <span class="p">(</span> <span class="n">magic</span> <span class="o">==</span> <span class="mh">0x9678E7E2</span> <span class="p">)</span> <span class="c1">// getpriority
</span><span class="c1"></span><span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span> <span class="o">*</span><span class="n">v37</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">)</span>
    <span class="n">parent_regs</span><span class="p">.</span><span class="n">eax</span> <span class="o">=</span> <span class="o">*</span><span class="n">v37</span><span class="p">;</span>
  <span class="k">else</span>
    <span class="n">parent_regs</span><span class="p">.</span><span class="n">eax</span> <span class="o">=</span> <span class="o">*</span><span class="n">v37</span> <span class="o">+</span> <span class="mi">20</span><span class="p">;</span>
  <span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_SETREGS</span><span class="p">,</span> <span class="n">parent_pid</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">&amp;</span><span class="n">parent_regs</span><span class="p">);</span>
  <span class="o">*</span><span class="n">v37</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="p">[...]</span>

<span class="k">else</span> <span class="k">if</span> <span class="p">(</span> <span class="n">magic</span> <span class="o">==</span> <span class="mh">0x83411CE4</span> <span class="p">)</span> <span class="c1">// setpriority
</span><span class="c1"></span><span class="p">{</span>
  <span class="n">buf</span> <span class="o">=</span> <span class="n">get_string</span><span class="p">(</span><span class="n">parent_regs</span><span class="p">.</span><span class="n">edx</span><span class="p">);</span>
  <span class="n">v4</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">((</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">buf</span><span class="p">);</span>
  <span class="n">copy_to_pid</span><span class="p">(</span><span class="n">parent_pid</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">dword_81A52A0</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span><span class="n">buf</span><span class="p">,</span> <span class="n">v4</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
  <span class="o">*</span><span class="n">v37</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">dword_81A52A0</span><span class="p">;</span>
  <span class="n">free</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
  <span class="n">parent_regs</span><span class="p">.</span><span class="n">eax</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_SETREGS</span><span class="p">,</span> <span class="n">parent_pid</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">&amp;</span><span class="n">parent_regs</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>Let&rsquo;s take a look at the flow of our <code>nice</code> call:</p>
<ol>
<li><code>getpriority</code> is invoked for the first time. This time <code>v37</code> points to <code>dword_81A52A0</code> (it has been initialized at the start of <code>child1_main</code>), so <em>child1</em> returns this value + 20 which doesn&rsquo;t help us that much</li>
<li><code>setpriority</code> is invoked with the <code>incr</code> of the original <code>nice</code> argument as its argument. Then, it gets a string using this argument as the parameter, copies this string to <code>dword_81A52A0</code> (let&rsquo;s refer to is as <code>nice_buffer</code> from now on) in the <em>parent,</em> and finally sets <code>v37</code> to point to <code>-nice_buffer</code></li>
<li><code>getpriority</code> is invoked for the second time. This time <code>v37</code> is negative, so this will return our <code>-nice_buffer</code></li>
</ol>
<p>This is how <code>nice</code> is able to get a string to <em>parent.</em></p>
<h3 id="understanding-truncate">Understanding <em>truncate</em></h3>
<p>Next, we&rsquo;ll look at the <code>truncate</code> call. <em>Parent</em> passes the address of <code>file</code> and 32 to it, while it expects the value to be 32. Examining <code>file</code> we see a big buffer that contains a lot of data but we&rsquo;re not sure what it is yet.</p>
<a class="lightgallery" href="/posts/flare-on-7-break/images/image_13.png" title="/posts/flare-on-7-break/images/image_13.png" data-thumbnail="/posts/flare-on-7-break/images/image_13.png">
        <img
            class="lazyload"
            src="/svg/loading.min.svg"
            data-src="images/image_13.png"
            data-srcset="/posts/flare-on-7-break/images/image_13.png, images/image_13.png 1.5x, /posts/flare-on-7-break/images/image_13.png 2x"
            data-sizes="auto"
            alt="/posts/flare-on-7-break/images/image_13.png" />
    </a>
<p>Before calling <code>truncate</code>, <code>check_rest_input</code> copies the next 32 bytes of our input into the start of that big buffer. Let&rsquo;s change its name to <code>huge_buffer</code> and keep in mind that that our input is at its start while analyzing the next part. You know the drill - we need to calculate the magic value of <code>truncate</code> and get to the code in <em>child1</em> that handles it.</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">case</span> <span class="mh">0x4A51739A</span><span class="o">:</span>              <span class="c1">// truncate
</span><span class="c1"></span>  <span class="n">copy_from_pid</span><span class="p">(</span><span class="n">parent_pid</span><span class="p">,</span> <span class="n">parent_regs</span><span class="p">.</span><span class="n">ebx</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">huge_buffer</span><span class="p">,</span> <span class="mi">40000</span><span class="p">);</span>
  <span class="k">for</span> <span class="p">(</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">39999</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="p">(</span><span class="n">_BYTE</span> <span class="o">*</span><span class="p">)(</span><span class="n">i</span> <span class="o">+</span> <span class="mh">0x804C640</span><span class="p">);</span> <span class="o">++</span><span class="n">i</span> <span class="p">)</span>
  <span class="p">{</span>
    <span class="n">v14</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">_BYTE</span> <span class="o">*</span><span class="p">)(</span><span class="n">i</span> <span class="o">+</span> <span class="mh">0x804C640</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">v42</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">v14</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="o">*</span><span class="p">(</span><span class="n">_BYTE</span> <span class="o">*</span><span class="p">)(</span><span class="n">i</span> <span class="o">+</span> <span class="n">v</span><span class="p">)</span> <span class="p">)</span>
      <span class="n">v42</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">v42</span> <span class="o">=</span> <span class="n">v40</span><span class="p">(</span><span class="mh">0xA4F57126</span><span class="p">,</span> <span class="n">input_buffer</span><span class="p">,</span> <span class="n">v42</span><span class="p">);</span>
  <span class="n">parent_regs</span><span class="p">.</span><span class="n">eax</span> <span class="o">=</span> <span class="n">v42</span><span class="p">;</span>
  <span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_SETREGS</span><span class="p">,</span> <span class="n">parent_pid</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">&amp;</span><span class="n">parent_regs</span><span class="p">);</span>
  <span class="k">break</span><span class="p">;</span>
</code></pre></div><p>Looking at the local variables here, <code>v14</code> is a local buffer that&rsquo;s 16000 bytes in size and we&rsquo;ll refer to it as <code>child1_16000_buff</code>, while <code>v40</code> is simply initialized to <code>0</code> in <code>child1_main</code> and never changed later so we&rsquo;ll rename it to <code>zero</code>. We also have here references to 2 addresses:</p>
<ul>
<li><code>0x804C640</code> - which is the address of our <code>huge_buffer</code></li>
<li><code>0x81A5100</code> - address that points to 32 bytes of unknown data</li>
</ul>
<a class="lightgallery" href="/posts/flare-on-7-break/images/image_14.png" title="/posts/flare-on-7-break/images/image_14.png" data-thumbnail="/posts/flare-on-7-break/images/image_14.png">
        <img
            class="lazyload"
            src="/svg/loading.min.svg"
            data-src="images/image_14.png"
            data-srcset="/posts/flare-on-7-break/images/image_14.png, images/image_14.png 1.5x, /posts/flare-on-7-break/images/image_14.png 2x"
            data-sizes="auto"
            alt="/posts/flare-on-7-break/images/image_14.png" />
    </a>
<p>So what&rsquo;s going on here is that after copying the huge_buffer from the <em>parent</em> (which contains our input) to the same address in <em>child1,</em> there will run a for loop that will iterate the 40000 bytes in this buffer, copy every byte into <code>child1_16000_buff</code> (mind you we&rsquo;re copying 40000 bytes into a 16000 bytes buffer. We&rsquo;ll see why in the future), and will compare this <code>huge_buffer</code> to the data that is at <code>0x81A5100</code>. Finally, it&rsquo;ll store the number of equal bytes in <code>v42</code> (we&rsquo;ll rename it to <code>equal_bytes_count</code>).</p>
<p>So the next 32 characters of our input basically get modified by <code>check_rest_input</code> and the result of this modification is compared to the 32 bytes at <code>0x81A5100</code>. Now we have 2 options to choose from:</p>
<ol>
<li>Assume this is a classic implementation of a known algorithm, identify it, and use it to understand what input we need to provide.</li>
<li>Understand this algorithm better, and perform the reverse process, to get the input we need from the result the binary expects.</li>
</ol>
<p>Option 1 tends to be the easier and faster option to use if that&rsquo;s really the case, but even though we&rsquo;ll see some known crypto constants being used by <code>check_rest_input</code>, this doesn&rsquo;t seem to be the case here (we&rsquo;ll cover those in a bit).</p>
<p>Since option 1 is not relevant here, we&rsquo;ll go for the second one. There are many ways to peel a potato, and we&rsquo;d like to show 2 great methods of approaching this - Hooking and debugging.</p>
<h2 id="understanding-the-second-check">Understanding the Second Check</h2>
<p>Before we dive into each of our chosen methods, we need to better understand the algorithm in order to understand what it is we&rsquo;re actually after so we&rsquo;ll continue looking at the functions that <code>check_rest_input</code> calls.</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">_BOOL4</span> <span class="kr">__cdecl</span> <span class="nf">check_rest_input</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">rest_input_buffer</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">s</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">-</span><span class="n">nice</span><span class="p">(</span><span class="mh">0xA4</span><span class="p">);</span>
  <span class="n">v1</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
  <span class="n">v5</span> <span class="o">=</span> <span class="n">sub_804BFED</span><span class="p">(</span><span class="mi">0LL</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">s</span><span class="p">,</span> <span class="n">v1</span><span class="p">);</span>
  <span class="n">v4</span> <span class="o">=</span> <span class="mi">40000</span><span class="p">;</span>
  <span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">huge_buffer</span><span class="p">,</span> <span class="n">rest_input_buffer</span><span class="p">,</span> <span class="mh">0x20u</span><span class="p">);</span>
  <span class="k">for</span> <span class="p">(</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">v4</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">8</span> <span class="p">)</span>
    <span class="n">sub_804C369</span><span class="p">((</span><span class="n">__mode_t</span> <span class="o">*</span><span class="p">)(</span><span class="o">&amp;</span><span class="n">huge_buffer</span> <span class="o">+</span> <span class="n">i</span><span class="p">),</span> <span class="n">v5</span><span class="p">,</span> <span class="n">SHIDWORD</span><span class="p">(</span><span class="n">v5</span><span class="p">),</span> <span class="n">v3</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">truncate</span><span class="p">(</span><span class="o">&amp;</span><span class="n">huge_buffer</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span> <span class="o">==</span> <span class="mi">32</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>Starting with <code>sub_804BFED</code>:</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">unsigned</span> <span class="kr">__int64</span> <span class="kr">__cdecl</span> <span class="nf">sub_804BFED</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kr">__int64</span> <span class="n">a1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">a2</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kr">__int64</span> <span class="n">a3</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0LL</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">a3</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span> <span class="p">)</span>
  <span class="p">{</span>
    <span class="n">v3</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kr">__int8</span><span class="p">)(</span><span class="o">*</span><span class="p">(</span><span class="n">_BYTE</span> <span class="o">*</span><span class="p">)(</span><span class="n">i</span> <span class="o">+</span> <span class="n">a2</span><span class="p">)</span> <span class="o">^</span> <span class="n">a1</span><span class="p">);</span>
    <span class="n">LODWORD</span><span class="p">(</span><span class="n">a1</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">a1</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">^</span> <span class="n">dword_8056960</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">v3</span><span class="p">];</span>
    <span class="n">HIDWORD</span><span class="p">(</span><span class="n">a1</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">HIDWORD</span><span class="p">(</span><span class="n">a1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">^</span> <span class="n">dword_8056964</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">v3</span><span class="p">];</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">a1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>Since this function only performs some arithmetic operations on the string we got from the call <code>s = -nice(0xA4)</code> (that we already decrypted so we know it&rsquo;s <code>'This string has no purpose and is merely here to waste your time.'</code>), it&rsquo;ll be easy to get the result of it. Whether it&rsquo;s by implementing it with Python or examining the value during runtime.  So we&rsquo;ll continue right away to the second function <code>sub_804C369</code> which is much more interesting.</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">unsigned</span> <span class="kt">int</span> <span class="kr">__cdecl</span> <span class="nf">sub_804C369</span><span class="p">(</span><span class="n">__mode_t</span> <span class="o">*</span><span class="n">a1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">a2</span><span class="p">,</span> <span class="kt">int</span> <span class="n">a3</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">a4</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">v11</span> <span class="o">=</span> <span class="n">__readgsdword</span><span class="p">(</span><span class="mh">0x14u</span><span class="p">);</span>
  <span class="n">v6</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">sub_804C217</span><span class="p">(</span><span class="n">__PAIR64__</span><span class="p">(</span><span class="n">a3</span><span class="p">,</span> <span class="n">a2</span><span class="p">),</span> <span class="mi">16</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">a4</span><span class="p">);</span>
  <span class="n">v7</span> <span class="o">=</span> <span class="o">*</span><span class="n">a1</span><span class="p">;</span>
  <span class="n">mode</span> <span class="o">=</span> <span class="n">a1</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
  <span class="n">v5</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">v9</span> <span class="o">=</span> <span class="n">mode</span><span class="p">;</span>
  <span class="n">v10</span> <span class="o">=</span> <span class="n">v7</span> <span class="o">^</span> <span class="n">chmod</span><span class="p">(</span><span class="n">a4</span><span class="p">,</span> <span class="n">mode</span><span class="p">);</span>
  <span class="n">v7</span> <span class="o">=</span> <span class="n">mode</span><span class="p">;</span>
  <span class="n">mode</span> <span class="o">=</span> <span class="n">v10</span><span class="p">;</span>
  <span class="n">MEMORY</span><span class="p">[</span><span class="mi">0</span><span class="p">](</span><span class="o">&amp;</span><span class="n">loc_804C3C4</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">v5</span><span class="p">);</span>
  <span class="o">*</span><span class="n">a1</span> <span class="o">=</span> <span class="n">mode</span><span class="p">;</span>
  <span class="n">a1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">v7</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">__readgsdword</span><span class="p">(</span><span class="mh">0x14u</span><span class="p">)</span> <span class="o">^</span> <span class="n">v11</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>First, let&rsquo;s examine the unique mechanisms we have here. We notice right away there is another invocation of address 0, which will send a <code>SIGSEGV</code> signal to <em>child1</em> this time. Here is the code from <code>child1_main</code> that handles it:</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">if</span> <span class="p">(</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="mh">0xFF00</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span> <span class="o">==</span> <span class="n">SIGSEGV</span> <span class="p">)</span>
<span class="p">{</span>
  <span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_GETREGS</span><span class="p">,</span> <span class="n">parent_pid</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">&amp;</span><span class="n">parent_regs</span><span class="p">);</span>
  <span class="n">ret_addr</span> <span class="o">=</span> <span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_PEEKDATA</span><span class="p">,</span> <span class="n">parent_pid</span><span class="p">,</span> <span class="n">parent_regs</span><span class="p">.</span><span class="n">esp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="n">arg1</span> <span class="o">=</span> <span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_PEEKDATA</span><span class="p">,</span> <span class="n">parent_pid</span><span class="p">,</span> <span class="n">parent_regs</span><span class="p">.</span><span class="n">esp</span> <span class="o">+</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="n">arg2</span> <span class="o">=</span> <span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_PEEKDATA</span><span class="p">,</span> <span class="n">parent_pid</span><span class="p">,</span> <span class="n">parent_regs</span><span class="p">.</span><span class="n">esp</span> <span class="o">+</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="n">deref_arg2</span> <span class="o">=</span> <span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_PEEKDATA</span><span class="p">,</span> <span class="n">parent_pid</span><span class="p">,</span> <span class="n">arg2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
  <span class="n">parent_regs</span><span class="p">.</span><span class="n">esp</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span> <span class="n">deref_arg2</span> <span class="o">&gt;</span> <span class="mh">0xF</span> <span class="p">)</span>
  <span class="p">{</span>
    <span class="n">parent_regs</span><span class="p">.</span><span class="n">eip</span> <span class="o">=</span> <span class="n">ret_addr</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">else</span>
  <span class="p">{</span>
    <span class="n">parent_regs</span><span class="p">.</span><span class="n">eip</span> <span class="o">=</span> <span class="n">arg1</span><span class="p">;</span>
    <span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_POKEDATA</span><span class="p">,</span> <span class="n">parent_pid</span><span class="p">,</span> <span class="n">arg2</span><span class="p">,</span> <span class="n">deref_arg2</span><span class="p">);</span>
    <span class="n">parent_regs</span><span class="p">.</span><span class="n">esp</span> <span class="o">+=</span> <span class="mi">16</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_SETREGS</span><span class="p">,</span> <span class="n">parent_pid</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">&amp;</span><span class="n">parent_regs</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>This piece of code reads the return address and two arguments from the stack, then dereferences arg2 to get the value it points to, and finally pops the return address off of the stack. After that, the value in arg2 is tested against 15 - if it&rsquo;s bigger than 15, the code will set the <em>parent</em> instruction pointer to the return address, and will just return normally without doing much. But if this value is smaller than 15, the <em>parent</em>&rsquo;s instruction pointer will be set to the first argument and the stack will be unwound. Let&rsquo;s go back to look at the arguments that this piece of code gets, to make some sense out of this.</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">MEMORY</span><span class="p">[</span><span class="mi">0</span><span class="p">](</span><span class="o">&amp;</span><span class="n">loc_804C3C4</span><span class="p">,</span> <span class="n">v5</span><span class="p">);</span>
</code></pre></div><p>The first one is the address <code>0x804C3C4</code> which is located just a few instructions above the <code>call 0</code>, and the second argument is a local variable. We can now understand that this is a loop!</p>
<p>When the code gets to the dynamic call at <code>0x804C40C</code> it will loop around to the start of the basic block at <code>0x804C3C4</code> and this will happen 16 times, while the local variable <code>v5</code> will hold the loop counter (initialized to zero before the loop and incremented every iteration by <em>child1</em>).</p>
<p>The next thing we&rsquo;d better look at in <code>sub_804C369</code> and in <code>sub_804C217</code> (which it invokes) is the invocation of glibc functions since we already know they don&rsquo;t function as usual. There&rsquo;s a use in <code>chmod</code>, <code>pivot_root</code>, <code>mlockall</code> and <code>uname</code>. We&rsquo;ll do our thing again - calculate the magic value and locate the relevant code in <code>child1_main</code>:</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">if</span> <span class="p">(</span> <span class="n">magic</span> <span class="o">==</span> <span class="mh">0xE8135594</span> <span class="p">)</span>          <span class="c1">// pivot_root
</span><span class="c1"></span><span class="p">{</span>
  <span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_POKEDATA</span><span class="p">,</span> <span class="n">parent_pid</span><span class="p">,</span> <span class="n">parent_regs</span><span class="p">.</span><span class="n">ebx</span><span class="p">,</span> <span class="n">parent_regs</span><span class="p">.</span><span class="n">ecx</span><span class="p">);</span>
<span class="p">}</span>

<span class="p">[.</span> <span class="p">.</span> <span class="p">.]</span>

<span class="k">else</span> <span class="k">if</span> <span class="p">(</span> <span class="n">magic</span> <span class="o">==</span> <span class="mh">0x9C7A9D6</span> <span class="p">)</span>      <span class="c1">// uname
</span><span class="c1"></span><span class="p">{</span>
  <span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_POKEDATA</span><span class="p">,</span> <span class="n">parent_pid</span><span class="p">,</span> <span class="n">parent_regs</span><span class="p">.</span><span class="n">ebx</span><span class="p">,</span> <span class="mh">0xC6EF3720</span><span class="p">);</span>
  <span class="n">v6</span> <span class="o">=</span> <span class="n">zero</span><span class="p">(</span><span class="mh">0x7E85DB2Au</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="mh">0x1337</span><span class="p">,</span> <span class="mh">0xCAFE</span><span class="p">);</span>
  <span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_POKEDATA</span><span class="p">,</span> <span class="n">parent_pid</span><span class="p">,</span> <span class="n">parent_regs</span><span class="p">.</span><span class="n">ebx</span> <span class="o">+</span> <span class="mi">4</span><span class="p">,</span> <span class="n">v6</span><span class="p">);</span>
<span class="p">}</span>

<span class="p">[.</span> <span class="p">.</span> <span class="p">.]</span>

<span class="k">if</span> <span class="p">(</span> <span class="n">magic</span> <span class="o">==</span> <span class="mh">0xC93DE012</span> <span class="p">)</span>          <span class="c1">// mlockall
</span><span class="c1"></span><span class="p">{</span>
  <span class="n">LODWORD</span><span class="p">(</span><span class="n">v13</span><span class="p">)</span> <span class="o">=</span> <span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_PEEKDATA</span><span class="p">,</span> <span class="n">parent_pid</span><span class="p">,</span> <span class="n">parent_regs</span><span class="p">.</span><span class="n">ebx</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="n">HIDWORD</span><span class="p">(</span><span class="n">v13</span><span class="p">)</span> <span class="o">=</span> <span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_PEEKDATA</span><span class="p">,</span> <span class="n">parent_pid</span><span class="p">,</span> <span class="n">parent_regs</span><span class="p">.</span><span class="n">ebx</span> <span class="o">+</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="n">v43</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">while</span> <span class="p">(</span> <span class="n">v13</span> <span class="p">)</span>
  <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span> <span class="p">(</span><span class="n">v13</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">)</span>
      <span class="n">v43</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">zero</span><span class="p">(</span><span class="mh">0xB82D3C24</span><span class="p">,</span> <span class="n">v43</span><span class="p">,</span> <span class="n">HIDWORD</span><span class="p">(</span><span class="n">v13</span><span class="p">));</span>
    <span class="n">v13</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">parent_regs</span><span class="p">.</span><span class="n">eax</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">v43</span><span class="p">;</span>
  <span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_SETREGS</span><span class="p">,</span> <span class="n">parent_pid</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">&amp;</span><span class="n">parent_regs</span><span class="p">);</span>
<span class="p">}</span>

<span class="p">[.</span> <span class="p">.</span> <span class="p">.]</span>

<span class="k">else</span> <span class="k">if</span> <span class="p">(</span> <span class="n">magic</span> <span class="o">==</span> <span class="mh">0xAB202240</span> <span class="p">)</span>     <span class="c1">// chmod
</span><span class="c1"></span><span class="p">{</span>
  <span class="n">copy_from_pid</span><span class="p">(</span><span class="n">parent_pid</span><span class="p">,</span> <span class="n">parent_regs</span><span class="p">.</span><span class="n">ebx</span><span class="p">,</span> <span class="n">v11</span><span class="p">,</span> <span class="mi">248</span><span class="p">);</span>
  <span class="n">parent_regs</span><span class="p">.</span><span class="n">eax</span> <span class="o">=</span> <span class="n">sub_804C19C</span><span class="p">(</span><span class="n">v11</span><span class="p">,</span> <span class="n">parent_regs</span><span class="p">.</span><span class="n">ecx</span><span class="p">);</span>
  <span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_SETREGS</span><span class="p">,</span> <span class="n">parent_pid</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">&amp;</span><span class="n">parent_regs</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>Let&rsquo;s see what each function is doing.</p>
<ul>
<li>
<p><code>pivot_root</code> - writes the value of <code>ecx</code> into <code>ebx</code> (second parameter into the third one)</p>
</li>
<li>
<p><code>uname</code> - writes the DWORD <code>0xC6EF3720</code> to <code>ebx</code> (first parameter). You may recognize this constant value as a crypto constant from <em><a href="https://en.wikipedia.org/wiki/Tiny_Encryption_Algorithm" target="_blank" rel="noopener noreffer">TEA</a>,</em> but as we&rsquo;ll soon see this is just a red herring. Then it invokes address zero again, but keep in mind that we&rsquo;re already executing in the context of <em>child1</em>, so if we ignore the patching we made to get rid of <em>child2</em>, we need to look at the code that&rsquo;s handling the <code>SIGSEGV</code> in <em>child2</em> and locate the correct code path for the argument <code>0x7E85DB2A</code><em>.</em></p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">case</span> <span class="mh">0x7E85DB2A</span><span class="o">:</span>
    <span class="n">child1_regs</span><span class="p">.</span><span class="n">eax</span> <span class="o">=</span> <span class="mh">0x9E3779B9</span><span class="p">;</span>
    <span class="k">break</span><span class="p">;</span>
</code></pre></div><p>Turns out it only returns <code>0x9E3779B9</code>, which is yet another red herring to <em>TEA.</em> So this value is being written to <code>ebx+4</code>.</p>
</li>
<li>
<p><code>mlockall</code> - this one takes a full 8 bytes from <code>ebx</code> and then iterates all the bits in it. In every loop iteration, it calls <code>zero</code> again, this time with the argument <code>0xB82D3C24</code>. Locating the relevant code in <em>child2</em> shows us this:</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">case</span> <span class="mh">0xB82D3C24</span><span class="o">:</span>
    <span class="n">child1_regs</span><span class="p">.</span><span class="n">eax</span> <span class="o">=</span> <span class="n">arg1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</code></pre></div><p>So it simply does <code>v43++</code>. This means <code>mlockall</code> will return the number of bits set to one in the 8-byte argument.</p>
</li>
<li>
<p><code>chmod</code> - copies 248 bytes from the first argument that <em>parent</em> supplied, and then calls <code>sub_804C19C</code> with the bytes copied and the second argument it got.</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">int</span> <span class="kr">__cdecl</span> <span class="nf">sub_804C19C</span><span class="p">(</span><span class="n">_DWORD</span> <span class="o">*</span><span class="n">copied_bytes</span><span class="p">,</span> <span class="kt">int</span> <span class="n">arg2</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">v2</span> <span class="o">=</span> <span class="n">MEMORY</span><span class="p">[</span><span class="mi">0</span><span class="p">](</span><span class="mh">0x6B4E102C</span><span class="p">,</span> <span class="n">arg2</span><span class="p">,</span> <span class="n">copied_bytes</span><span class="p">[</span><span class="mi">7</span><span class="p">]);</span>
  <span class="n">v3</span> <span class="o">=</span> <span class="n">MEMORY</span><span class="p">[</span><span class="mi">0</span><span class="p">](</span><span class="mh">0x5816452E</span><span class="p">,</span> <span class="n">v2</span><span class="p">,</span> <span class="n">copied_bytes</span><span class="p">[</span><span class="mi">41</span><span class="p">]);</span>
  <span class="k">return</span> <span class="n">MEMORY</span><span class="p">[</span><span class="mi">0</span><span class="p">](</span><span class="mh">0x44DE7A30</span><span class="p">,</span> <span class="n">v3</span><span class="p">,</span> <span class="n">copied_bytes</span><span class="p">[</span><span class="mi">19</span><span class="p">]);</span>
<span class="p">}</span>
</code></pre></div><p>This function once again triggers a <code>SIGSEGV</code>, so let&rsquo;s look at the relevant cases in <em>child2:</em></p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">case</span> <span class="mh">0x6B4E102C</span><span class="o">:</span>
    <span class="n">child1_regs</span><span class="p">.</span><span class="n">eax</span> <span class="o">=</span> <span class="n">arg1</span> <span class="o">+</span> <span class="n">arg2</span><span class="p">;</span>
    <span class="k">break</span><span class="p">;</span>

<span class="p">[</span> <span class="p">.</span> <span class="p">.</span> <span class="p">.]</span>

<span class="k">case</span> <span class="mh">0x5816452E</span><span class="o">:</span>
  <span class="n">child1_regs</span><span class="p">.</span><span class="n">eax</span> <span class="o">=</span> <span class="n">sub_804C163</span><span class="p">(</span><span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">);</span>
  <span class="k">break</span><span class="p">;</span>

<span class="p">[</span> <span class="p">.</span> <span class="p">.</span> <span class="p">.]</span>

<span class="k">if</span> <span class="p">(</span> <span class="n">magic</span> <span class="o">==</span> <span class="mh">0x44DE7A30</span> <span class="p">)</span>
<span class="p">{</span>
  <span class="n">child1_regs</span><span class="p">.</span><span class="n">eax</span> <span class="o">=</span> <span class="n">arg2</span> <span class="o">^</span> <span class="n">arg1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>It&rsquo;s very clear that <code>0x6B4E102C</code> is doing addition and that <code>0x44DE7A30</code> is XORing the two arguments. And if we take a look at <code>sub_804C163</code> we can see the simple calculation that <code>0x5816452E</code> is doing.</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">unsigned</span> <span class="kt">int</span> <span class="kr">__cdecl</span> <span class="nf">sub_804C163</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">a1</span><span class="p">,</span> <span class="kt">char</span> <span class="n">a2</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="p">(</span><span class="n">a1</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">a2</span> <span class="o">&amp;</span> <span class="mh">0x1F</span><span class="p">))</span> <span class="o">|</span> <span class="p">(</span><span class="n">a1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">a2</span> <span class="o">&amp;</span> <span class="mh">0x1F</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x1F</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div></li>
</ul>
<p>Armed with that knowledge, let&rsquo;s dive into that algorithm in <code>check_rest_flag</code>. Let&rsquo;s rename <code>sub_804C369</code> to <code>decrypt_block</code> and look at our algorithm.</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">for</span> <span class="p">(</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">v4</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">8</span> <span class="p">)</span>
  <span class="n">decode_block</span><span class="p">((</span><span class="n">__mode_t</span> <span class="o">*</span><span class="p">)(</span><span class="o">&amp;</span><span class="n">huge_buffer</span> <span class="o">+</span> <span class="n">i</span><span class="p">),</span> <span class="n">value_64bit</span><span class="p">,</span> <span class="n">SHIDWORD</span><span class="p">(</span><span class="n">value_64bit</span><span class="p">),</span> <span class="n">buffer_3968</span><span class="p">);</span>
<span class="k">return</span> <span class="nf">truncate</span><span class="p">(</span><span class="o">&amp;</span><span class="n">huge_buffer</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span> <span class="o">==</span> <span class="mi">32</span><span class="p">;</span>
</code></pre></div><p>So it calls <code>decrypt_block</code> every 8 bytes, passing the current block as the first argument, alongside the 64-bit number calculated base on the string from <code>nice</code>, and a local buffer of 3968 bytes.</p>
<p>The decompiler struggles here (probably due to the weird loop mechanism), so we&rsquo;ll try to write the pseudo-code for <code>decrypt_block</code> ourselves.</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">unsigned</span> <span class="kt">int</span> <span class="kr">__cdecl</span> <span class="nf">decode_block</span><span class="p">(</span><span class="n">__mode_t</span> <span class="o">*</span><span class="n">block</span><span class="p">,</span> <span class="kt">int</span> <span class="n">value_64bit_l</span><span class="p">,</span> <span class="kt">int</span> <span class="n">value_64bit_h</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buffer_3968</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">v11</span> <span class="o">=</span> <span class="n">__readgsdword</span><span class="p">(</span><span class="mh">0x14u</span><span class="p">);</span>
  <span class="n">v6</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">sub_804C217</span><span class="p">(</span><span class="n">__PAIR64__</span><span class="p">(</span><span class="n">value_64bit_h</span><span class="p">,</span> <span class="n">value_64bit_l</span><span class="p">),</span> <span class="mi">16</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">buffer_3968</span><span class="p">);</span>
  <span class="n">current_dword</span> <span class="o">=</span> <span class="o">*</span><span class="n">block</span><span class="p">;</span>
  <span class="n">next_dword</span> <span class="o">=</span> <span class="n">block</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
  <span class="n">exec_counter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
	<span class="p">{</span>
	  <span class="n">v10</span> <span class="o">=</span> <span class="n">current_dword</span> <span class="o">^</span> <span class="n">chmod</span><span class="p">(</span><span class="n">buffer_3968</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="mh">0xf8</span><span class="p">],</span> <span class="n">next_dword</span><span class="p">);</span>
	  <span class="n">current_dword</span> <span class="o">=</span> <span class="n">next_dword</span><span class="p">;</span>
	  <span class="n">next_dword</span> <span class="o">=</span> <span class="n">v10</span><span class="p">;</span>
	<span class="p">}</span>
  <span class="o">*</span><span class="n">block</span> <span class="o">=</span> <span class="n">next_dword</span><span class="p">;</span>
  <span class="n">block</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">current_dword</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">__readgsdword</span><span class="p">(</span><span class="mh">0x14u</span><span class="p">)</span> <span class="o">^</span> <span class="n">v11</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>This looks like something we can easily reverse in Python. Let&rsquo;s just see what else we got in <code>sub_804C217</code>, it should initialize <code>buffer_3968</code> since no one else does. This function uses the unique loop mechanism as well, so again we&rsquo;ll freely decompile the function our own (or just follow the assembly since this is a short function):</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">_DWORD</span> <span class="o">*</span><span class="kr">__cdecl</span> <span class="nf">sub_804C217</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kr">__int64</span> <span class="n">value_64bit</span><span class="p">,</span> <span class="kt">int</span> <span class="n">a2</span><span class="p">,</span> <span class="n">_DWORD</span> <span class="o">*</span><span class="n">buffer_3968</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">v9</span> <span class="o">=</span> <span class="n">__readgsdword</span><span class="p">(</span><span class="mh">0x14u</span><span class="p">);</span>
  <span class="n">var_30</span> <span class="o">=</span> <span class="n">value_64bit</span><span class="p">;</span>
  <span class="n">v5</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">exec_counter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
	<span class="p">{</span>
	  <span class="n">pivot_root</span><span class="p">(</span><span class="n">buffer_3968</span><span class="p">[</span><span class="n">i</span> <span class="o">*</span> <span class="mh">0xf8</span> <span class="o">+</span> <span class="mi">7</span><span class="p">],</span> <span class="n">value_64bit</span><span class="p">);</span>
	  <span class="n">pivot_root</span><span class="p">(</span><span class="n">buffer_3968</span><span class="p">[</span><span class="n">i</span> <span class="o">*</span> <span class="mh">0xf8</span> <span class="o">+</span> <span class="mh">0x13</span><span class="p">],</span> <span class="n">HIDWORD</span><span class="p">(</span><span class="n">value_64bit</span><span class="p">));</span>
	  <span class="n">buffer_3968</span><span class="p">[</span><span class="mh">0x29</span><span class="p">]</span> <span class="o">=</span> <span class="n">mlockall</span><span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="o">&amp;</span><span class="n">var_30</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
	  <span class="n">v6</span> <span class="o">=</span> <span class="n">var_30</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">;</span>
	  <span class="n">var_30</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span>
	  <span class="k">if</span> <span class="p">(</span> <span class="n">v6</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">)</span>
	  <span class="p">{</span>
	    <span class="n">uname</span><span class="p">(</span><span class="o">&amp;</span><span class="n">v8</span><span class="p">);</span>
	    <span class="n">var_30</span> <span class="o">^=</span> <span class="n">v8</span><span class="p">;</span>
	  <span class="p">}</span>
	<span class="p">}</span>
  <span class="n">v5</span><span class="p">(</span><span class="o">&amp;</span><span class="n">loc_804C257</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">exec_counter</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">buffer_3968</span><span class="p">;</span>
</code></pre></div><p>We&rsquo;ll start by solving this with the debugging method first, followed by the hooking method. Both are very similar and we wanted to show you both so you can have another opportunity to learn something new.</p>
<h3 id="debugging-method">Debugging Method</h3>
<p>Previously we show how we can get rid of <em>child2</em> by patching key points in <em>child1</em> and executing an infinite loop that will allow us to attach a debugger to it. Having such access to <em>child1</em> will allow us to easily grab the values we want from <code>pivot_root</code> and <code>mlockall</code>.</p>
<p>To start, execute the patched binary file:</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ ./break_patched
</code></pre></div><p>The program will hang in the infinite loop and this will allow us to attach the IDA debugger to it. Got to &ldquo;Debugger → Attach to process&rdquo; and search for &ldquo;break_patched&rdquo; (or the name you gave to your patched binary). Unlike before, now we only have two processes of break running, thanks to the method we used to get rid of <em>child2</em>. Choose <em>child1</em> (it will have a higher PID) and press OK to attach the debugger to it. We will land at the infinite loop.</p>
<a class="lightgallery" href="/posts/flare-on-7-break/images/image_15.png" title="/posts/flare-on-7-break/images/image_15.png" data-thumbnail="/posts/flare-on-7-break/images/image_15.png">
        <img
            class="lazyload"
            src="/svg/loading.min.svg"
            data-src="images/image_15.png"
            data-srcset="/posts/flare-on-7-break/images/image_15.png, images/image_15.png 1.5x, /posts/flare-on-7-break/images/image_15.png 2x"
            data-sizes="auto"
            alt="/posts/flare-on-7-break/images/image_15.png" />
    </a>
<p>Now, either set <code>eip</code> to point at one of the <code>nop</code> instructions (e.g <code>0x8049139</code>) or simply use &ldquo;Edit → Patch program → Change bytes&rdquo; and replace <code>EB FE</code> with <code>90 90</code>.</p>
<p>Now, we want to add two conditional breakpoints that will print to the screen the values from <code>pivot_root</code> and <code>mlockall</code>.</p>
<p>To print the value of <code>pivot_root</code> put a conditional breakpoint at <code>0x080496D8</code> with the following Python code that prints <code>edx</code>.</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">edx</span> <span class="o">=</span> <span class="n">get_reg_value</span><span class="p">(</span><span class="s2">&#34;edx&#34;</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="s2">&#34;pivot_root: {edx:#x}&#34;</span><span class="p">)</span>
</code></pre></div><p>Next, put a breakpoint at <code>0x080497AF</code> that will print the value from <code>mlockall</code> that resides in the <code>eax</code> register.</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">eax</span> <span class="o">=</span> <span class="n">get_reg_value</span><span class="p">(</span><span class="s2">&#34;eax&#34;</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="s2">&#34;mlockall: {eax}&#34;</span><span class="p">)</span>
</code></pre></div><p>Now click Continue so the debugger will run, and go to your terminal to give input to the program. Quickly go to IDA and pause the program. By now, you should see our prints on the Output window.</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">pivot_root</span><span class="p">:</span> <span class="mh">0x4b695809</span>
<span class="n">pivot_root</span><span class="p">:</span> <span class="mh">0x674a1dea</span>
<span class="n">mlockall</span><span class="p">:</span> <span class="mi">30</span>
<span class="n">pivot_root</span><span class="p">:</span> <span class="mh">0xe35b9b24</span>
<span class="n">pivot_root</span><span class="p">:</span> <span class="mh">0xad92774c</span>
<span class="n">mlockall</span><span class="p">:</span> <span class="mi">34</span>
<span class="n">pivot_root</span><span class="p">:</span> <span class="mh">0x71adcd92</span>
<span class="n">pivot_root</span><span class="p">:</span> <span class="mh">0x56c93ba6</span>
<span class="n">mlockall</span><span class="p">:</span> <span class="mi">34</span>
<span class="n">pivot_root</span><span class="p">:</span> <span class="mh">0x38d6e6c9</span>
<span class="n">pivot_root</span><span class="p">:</span> <span class="mh">0x2b649dd3</span>
<span class="n">mlockall</span><span class="p">:</span> <span class="mi">34</span>
<span class="n">pivot_root</span><span class="p">:</span> <span class="mh">0x5a844444</span>
<span class="n">pivot_root</span><span class="p">:</span> <span class="mh">0x8b853750</span>
<span class="n">mlockall</span><span class="p">:</span> <span class="mi">24</span>
<span class="n">pivot_root</span><span class="p">:</span> <span class="mh">0x2d422222</span>
<span class="n">pivot_root</span><span class="p">:</span> <span class="mh">0x45c29ba8</span>
<span class="n">mlockall</span><span class="p">:</span> <span class="mi">24</span>
<span class="p">[</span> <span class="o">.</span> <span class="o">.</span> <span class="o">.</span> <span class="p">]</span>
</code></pre></div><p>We can then use the values in our script and reveal the second part of the flag. Not before we will go over another method to achieve the same — the hooking method.</p>
<h3 id="hooking-method">Hooking Method</h3>
<p>Here&rsquo;s our plan:</p>
<ol>
<li>Hook <code>pivot_root</code> and <code>mlockall</code> in order to get all the values that are being used to initialize <code>buffer_3968</code></li>
<li>Implement a script that will initialize <code>buffer_3968</code> based on the values we got from our hooks</li>
<li>Finally, the script will reverse the process that&rsquo;s in <code>decrypt_block</code> to get from the data in that&rsquo;s at <code>0x81A5100</code> to the desired input (the flag)</li>
</ol>
<p>The easiest way to hook functions in a Linux environment is to use <a href="https://man7.org/linux/man-pages/man8/ld.so.8.html" target="_blank" rel="noopener noreffer">LD_PRELOAD</a>, which will make our shared object load into the process (our challenge) and give us the ability to hook glibc functions.</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// hook.c
</span><span class="c1">// gcc -m32 -shared -fPIC -D_GNU_SOURCE hook.c -o hook.so
</span><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;stdint.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;dlfcn.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">pivot_root</span> <span class="p">(</span><span class="kt">int</span> <span class="n">arg1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">arg2</span><span class="p">)</span>
<span class="p">{</span>	
	<span class="k">static</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">func_pivot_root</span><span class="p">)</span> <span class="p">(</span><span class="k">const</span> <span class="kt">void</span><span class="o">*</span><span class="p">,</span> <span class="n">size_t</span><span class="p">)</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span> <span class="n">func_pivot_root</span><span class="p">)</span>
		<span class="n">func_pivot_root</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span><span class="o">*</span><span class="p">,</span> <span class="n">size_t</span><span class="p">))</span> <span class="n">dlsym</span> <span class="p">(</span><span class="n">RTLD_NEXT</span><span class="p">,</span> <span class="s">&#34;pivot_root&#34;</span><span class="p">);</span>
	<span class="n">fprintf</span><span class="p">(</span><span class="n">stdout</span><span class="p">,</span> <span class="s">&#34;[HOOK] pivot_root a1: 0x%x a2: 0x%x </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">);</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">func_pivot_root</span> <span class="p">(</span><span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">mlockall</span> <span class="p">(</span><span class="kt">uint64_t</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>	
	<span class="k">static</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">func_mlockall</span><span class="p">)</span> <span class="p">(</span> <span class="n">size_t</span><span class="p">)</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span> <span class="n">func_mlockall</span><span class="p">)</span>
		<span class="n">func_mlockall</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span><span class="o">*</span><span class="p">,</span> <span class="n">size_t</span><span class="p">))</span> <span class="n">dlsym</span> <span class="p">(</span><span class="n">RTLD_NEXT</span><span class="p">,</span> <span class="s">&#34;mlockall&#34;</span><span class="p">);</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">func_mlockall</span> <span class="p">(</span><span class="n">arg</span><span class="p">);</span>
	<span class="n">fprintf</span><span class="p">(</span><span class="n">stdout</span><span class="p">,</span> <span class="s">&#34;[HOOK] mlockall() returned %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">retval</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>After compiling this shared object, let&rsquo;s execute our challenge and let it run until at least the first few blocks have been decrypted so our hooking will have a chance to print out the relevant values.</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ gcc -m32 -shared -fPIC -D_GNU_SOURCE hook.c -o hook.so
$ <span class="nv">LD_PRELOAD</span><span class="o">=</span>./hook.so ./break                                                   
welcome to the land of sunshine and rainbows!
as a reward <span class="k">for</span> getting this far in FLARE-ON, we<span class="err">&#39;</span>ve decided to make this one soooper easy

please enter a password friend :<span class="o">)</span> w3lc0mE_t0_Th3_l
<span class="o">[</span>HOOK<span class="o">]</span> pivot_root a1: 0xff86be58 a2: 0x4b695809
<span class="o">[</span>HOOK<span class="o">]</span> pivot_root a1: 0xff86be88 a2: 0x674a1dea
<span class="o">[</span>HOOK<span class="o">]</span> mlockall<span class="o">()</span> returned <span class="m">30</span>
<span class="o">[</span>HOOK<span class="o">]</span> pivot_root a1: 0xff86bf50 a2: 0xe35b9b24
<span class="o">[</span>HOOK<span class="o">]</span> pivot_root a1: 0xff86bf80 a2: 0xad92774c
<span class="o">[</span>HOOK<span class="o">]</span> mlockall<span class="o">()</span> returned <span class="m">34</span>
<span class="o">[</span>HOOK<span class="o">]</span> pivot_root a1: 0xff86c048 a2: 0x71adcd92
<span class="o">[</span>HOOK<span class="o">]</span> pivot_root a1: 0xff86c078 a2: 0x56c93ba6
<span class="o">[</span>HOOK<span class="o">]</span> mlockall<span class="o">()</span> returned <span class="m">34</span>

<span class="o">[</span> . . .<span class="o">]</span>
</code></pre></div><h3 id="calculating-the-2nd-part-of-the-flag">Calculating the 2nd part of the flag</h3>
<p>Hurray! Now with some VS Code magic in the form of regex replacements and multiline editing, we&rsquo;ll get those values into two arrays in the following script:</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="kn">from</span> <span class="nn">malduck</span> <span class="kn">import</span> <span class="n">p32</span><span class="p">,</span> <span class="n">unhex</span>

<span class="c1"># Construct buffer_3968 from pivot_root and mlockall hooks as in sub_804C217</span>
<span class="n">pivot</span> <span class="o">=</span> <span class="p">[</span><span class="mh">0x4b695809</span><span class="p">,</span> <span class="mh">0x674a1dea</span><span class="p">,</span> <span class="mh">0xe35b9b24</span><span class="p">,</span> <span class="mh">0xad92774c</span><span class="p">,</span> <span class="o">&lt;...</span><span class="n">snip</span><span class="o">...&gt;</span> <span class="p">,</span> <span class="mh">0x38d6e6c9</span><span class="p">]</span>
<span class="n">mlockall</span> <span class="o">=</span> <span class="p">[</span><span class="mi">30</span><span class="p">,</span> <span class="mi">34</span><span class="p">,</span> <span class="mi">34</span><span class="p">,</span> <span class="mi">34</span><span class="p">,</span> <span class="mi">24</span><span class="p">,</span> <span class="mi">24</span><span class="p">,</span> <span class="mi">24</span><span class="p">,</span> <span class="mi">42</span><span class="p">,</span> <span class="mi">42</span><span class="p">,</span> <span class="mi">42</span><span class="p">,</span> <span class="mi">42</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="o">&lt;...</span><span class="n">snip</span><span class="o">...&gt;</span><span class="p">,</span> <span class="mi">24</span><span class="p">,</span> <span class="mi">42</span><span class="p">]</span>
<span class="n">buffer_3968</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">16</span><span class="p">):</span>
    <span class="n">buffer_3968</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">pivot</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="mi">2</span><span class="p">],</span> <span class="n">pivot</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">mlockall</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">//</span><span class="mi">2</span><span class="p">])</span>

<span class="c1"># Define chmod to so it&#39;ll work the same as in the binary. Based on sub_804C19C</span>
<span class="k">def</span> <span class="nf">chmod</span><span class="p">(</span><span class="n">buffer_3968</span><span class="p">,</span> <span class="n">next_dword</span><span class="p">):</span>
    <span class="nb">sum</span> <span class="o">=</span> <span class="n">buffer_3968</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">next_dword</span> <span class="o">&amp;</span> <span class="mh">0xffffffff</span> 
    <span class="n">v3</span> <span class="o">=</span> <span class="p">(</span><span class="nb">sum</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">buffer_3968</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x1f</span><span class="p">))</span> <span class="o">|</span> <span class="p">(</span><span class="nb">sum</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">buffer_3968</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x1f</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x1f</span><span class="p">))</span> <span class="o">&amp;</span> <span class="mh">0xffffffff</span>
    <span class="k">return</span> <span class="n">v3</span> <span class="o">^</span> <span class="n">buffer_3968</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xffffffff</span>

<span class="c1"># Array from 0x81A5100</span>
<span class="n">desired_result</span> <span class="o">=</span> <span class="p">[</span><span class="mh">0x260A064</span><span class="p">,</span> <span class="mh">0x7D878AEA</span><span class="p">,</span> <span class="mh">0x0E47CE96C</span><span class="p">,</span> <span class="mh">0x0C2D3F82</span><span class="p">,</span> <span class="mh">0x0EBB5B78C</span><span class="p">,</span> <span class="mh">0x424F35CF</span><span class="p">,</span> <span class="mh">0x492BAD4F</span><span class="p">,</span> <span class="mh">0x0E07C2820</span><span class="p">]</span>

<span class="n">flag</span> <span class="o">=</span> <span class="sa">b</span><span class="s2">&#34;&#34;</span>

<span class="c1"># decrypt_block</span>
<span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
    <span class="n">next_dword</span> <span class="o">=</span> <span class="n">desired_result</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
    <span class="n">current_dword</span> <span class="o">=</span> <span class="n">desired_result</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">16</span><span class="p">):</span>
        <span class="n">xored</span> <span class="o">=</span> <span class="n">next_dword</span>
        <span class="n">next_dword</span> <span class="o">=</span> <span class="n">current_dword</span>
        <span class="n">current_dword</span> <span class="o">=</span> <span class="n">xored</span> <span class="o">^</span> <span class="n">chmod</span><span class="p">(</span><span class="n">buffer_3968</span><span class="p">[</span><span class="mi">15</span><span class="o">-</span><span class="n">i</span><span class="p">],</span> <span class="n">current_dword</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xffffffff</span>

    <span class="n">flag</span> <span class="o">+=</span> <span class="n">p32</span><span class="p">(</span><span class="n">current_dword</span><span class="p">)</span>
    <span class="n">flag</span> <span class="o">+=</span> <span class="n">p32</span><span class="p">(</span><span class="n">next_dword</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="n">flag</span><span class="p">)</span>
</code></pre></div><p>Running this script, we&rsquo;ll get <code>'4nD_0f_De4th_4nd_d3strUct1oN_4nd'</code>. looks like we reversed the process correctly and we got the rest of the flag. But oh no, seems to me that the flag is not complete yet.</p>
<h1 id="stage-3">Stage 3</h1>
<h2 id="getting-to-the-third-check">Getting to the Third Check</h2>
<p>Let&rsquo;s take a deep breath and continue to analyze the flow and see what&rsquo;s going on.</p>
<p>We&rsquo;ll see where the execution flow takes us by going back to <code>child1_main</code>, to the code that handles <code>truncate</code>.</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">case</span> <span class="mh">0x4A51739A</span><span class="o">:</span>              <span class="c1">// truncate
</span><span class="c1"></span>  <span class="n">copy_from_pid</span><span class="p">(</span><span class="n">parent_pid</span><span class="p">,</span> <span class="n">parent_regs</span><span class="p">.</span><span class="n">ebx</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">huge_buffer</span><span class="p">,</span> <span class="mi">40000</span><span class="p">);</span>
  <span class="k">for</span> <span class="p">(</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">39999</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="p">(</span><span class="n">_BYTE</span> <span class="o">*</span><span class="p">)(</span><span class="n">i</span> <span class="o">+</span> <span class="mh">0x804C640</span><span class="p">);</span> <span class="o">++</span><span class="n">i</span> <span class="p">)</span>
  <span class="p">{</span>
    <span class="n">child1_16000_buff</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">_BYTE</span> <span class="o">*</span><span class="p">)(</span><span class="n">i</span> <span class="o">+</span> <span class="mh">0x804C640</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">equal_bytes_count</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">child1_16000_buff</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="o">*</span><span class="p">(</span><span class="n">_BYTE</span> <span class="o">*</span><span class="p">)(</span><span class="n">i</span> <span class="o">+</span> <span class="mh">0x81A5100</span><span class="p">)</span> <span class="p">)</span>
      <span class="n">equal_bytes_count</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">equal_bytes_count</span> <span class="o">=</span> <span class="n">zero</span><span class="p">(</span><span class="mh">0xA4F57126</span><span class="p">,</span> <span class="n">input_buffer</span><span class="p">,</span> <span class="n">equal_bytes_count</span><span class="p">);</span>
  <span class="n">parent_regs</span><span class="p">.</span><span class="n">eax</span> <span class="o">=</span> <span class="n">equal_bytes_count</span><span class="p">;</span>
  <span class="n">ptrace</span><span class="p">(</span><span class="n">PTRACE_SETREGS</span><span class="p">,</span> <span class="n">parent_pid</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">&amp;</span><span class="n">parent_regs</span><span class="p">);</span>
  <span class="k">break</span><span class="p">;</span>
</code></pre></div><p>Having counted all the equal bytes <em>child1</em> will now trigger a <code>SIGSEGV</code> again and will hand control over to <em>child2</em>, passing the relevant magic number, our <code>input_buffer</code>, and the <code>equal_bytes_count</code>. Looking at the relevant code in <code>child2_main</code>, we see something a bit strange.</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">case</span> <span class="mh">0xA4F57126</span><span class="o">:</span>
  <span class="n">child1_regs</span><span class="p">.</span><span class="n">eax</span> <span class="o">=</span> <span class="n">arg2</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span> <span class="n">arg2</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="p">)</span>
  <span class="p">{</span>
    <span class="n">copy_from_pid</span><span class="p">(</span><span class="n">child1_pid</span><span class="p">,</span> <span class="n">arg1</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span><span class="n">input_buffer</span><span class="p">,</span> <span class="mi">62</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">strncmp</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="s">&#34;@no-flare.com&#34;</span><span class="p">,</span> <span class="mh">0xDu</span><span class="p">)</span> <span class="p">)</span>
      <span class="n">child1_regs</span><span class="p">.</span><span class="n">eax</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
</code></pre></div><p>Seems like the rest of the flag is compared to <code>&quot;@no-flare.com&quot;</code>, but at this point, I don&rsquo;t think anyone solving this challenge can believe this. It&rsquo;s yet another troll the challenge&rsquo;s author has planted in it. We need to try and think of a way the challenge author changes the execution flow of the code dynamically since this code clearly doesn&rsquo;t make sense. If you remember, not so long ago <code>child1_main</code> was copying a 40000 bytes buffer into a 16000 bytes one. Sounds like this thing can mess things up on our stack, and possibly subverting the original execution flow. The easiest way to see whether this is the case or not is to simply debug it and see with your own eyes. We showed how we can use the debugging method to get the second stage of the flag so we can do this here as well.</p>
<p>We&rsquo;re interested in seeing what happens in the basic block at <code>0x08049855</code>, right after our potential buffer overflow. Let&rsquo;s put a breakpoint in this address and execute the patched version of the binary as we did before. Similar to the previous execution, the program will hang in the <code>EB FE</code> and we can use a debugger to attach to it. Then, set the instruction pointer to one of the <code>nop</code> operations after the infinite loop and click Continue.</p>
<p>In your terminal, enter the correct two parts of the flag, and wait for a few minutes to give the challenge enough time to get to our loop and stop at the breakpoint (few minutes). Finally, the program will stop at <code>0x08049855</code>.</p>
<div class="highlight"><pre class="chroma"><code class="language-asm" data-lang="asm"><span class="nl">.text:</span><span class="err">08049855</span> <span class="nf">mov</span>     <span class="no">eax</span><span class="p">,</span> <span class="no">offset</span> <span class="no">input_buffer</span>
<span class="nl">.text:</span><span class="err">0804985</span><span class="nf">A</span> <span class="no">sub</span>     <span class="no">esp</span><span class="p">,</span> <span class="mi">4</span>
<span class="nl">.text:</span><span class="err">0804985</span><span class="nf">D</span> <span class="no">push</span>    <span class="p">[</span><span class="no">ebp</span><span class="err">+</span><span class="no">equal_bytes_cunt</span><span class="p">]</span>
<span class="nl">.text:</span><span class="err">08049860</span> <span class="nf">push</span>    <span class="no">eax</span>
<span class="nl">.text:</span><span class="err">08049861</span> <span class="nf">push</span>    <span class="mi">0</span><span class="no">A4F57126h</span>
<span class="nl">.text:</span><span class="err">08049866</span> <span class="nf">mov</span>     <span class="no">eax</span><span class="p">,</span> <span class="p">[</span><span class="no">ebp</span><span class="err">+</span><span class="no">zero</span><span class="p">]</span>
<span class="nl">.text:</span><span class="err">08049869</span> <span class="nf">call</span>    <span class="no">eax</span>
</code></pre></div><p>Let&rsquo;s examine the variables on the stack to see it we were correct. <code>ebp+equal_bytes_count</code> is still 32 as expected, but if we take a look at <code>ebp+zero</code> we see that it&rsquo;s not zero!</p>
<pre><code>[stack]:FFFEBEF0 dd offset unk_8053B70
</code></pre><p>It points to an address in the code section that we haven&rsquo;t seen before. We will continue stepping-into until we call this new code at <code>0x8053b70</code>. We can hit <code>C</code> and then <code>P</code> to define this as code and then as a function and we&rsquo;ll rename this to our <code>shellcode_start</code>.</p>
<h2 id="analyzing-the-shellcode">Analyzing the Shellcode</h2>
<p>This function will simply call another function, passing the arguments as they are.</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="kr">__cdecl</span> <span class="n">__noreturn</span> <span class="nf">shellcode_start</span><span class="p">(</span><span class="kt">int</span> <span class="n">a1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">a2</span><span class="p">,</span> <span class="kt">int</span> <span class="n">a3</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">sub_805492E</span><span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">,</span> <span class="n">a3</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>We have quite a lot going on in <code>sub_805492E</code>. We&rsquo;ll refer to it as the <code>shellcode_main</code> and start examining parts of the code.</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">v12</span> <span class="o">=</span> <span class="n">shellcode_start</span><span class="p">;</span>
<span class="n">v13</span> <span class="o">=</span> <span class="n">dword_81A5280</span><span class="p">;</span>
<span class="n">sub_8054C5C</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dword_81A5280</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="n">v3</span><span class="p">);</span>
</code></pre></div><p>Since we&rsquo;re dynamically debugging this, it&rsquo;s easy to see that <code>dword_81A5280</code> contains the <em>parent</em> PID and that <code>v12</code> contains the base of the shellcode so let&rsquo;s rename accordingly. The first function call we have is to <code>sub_8054C5C</code> which seems to be simply a wrapper around <code>ptrace</code> but it&rsquo;s switching the arguments around to confuse us. Let&rsquo;s rename that to <code>calls_ptrace</code> and keep in mind the new parameter order.</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">int</span> <span class="n">__usercall</span> <span class="n">calls_ptrace</span><span class="err">@</span><span class="o">&lt;</span><span class="n">eax</span><span class="o">&gt;</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="err">@</span><span class="o">&lt;</span><span class="n">ecx</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">pid_t</span> <span class="n">pid</span><span class="err">@</span><span class="o">&lt;</span><span class="n">edx</span><span class="o">&gt;</span><span class="p">,</span> <span class="kt">int</span> <span class="n">request</span><span class="err">@</span><span class="o">&lt;</span><span class="n">eax</span><span class="o">&gt;</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="nf">sys_ptrace</span><span class="p">(</span><span class="n">request</span><span class="p">,</span> <span class="n">pid</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">if</span> <span class="p">(</span> <span class="n">a3</span> <span class="o">!=</span> <span class="mi">32</span> <span class="p">)</span>
<span class="p">{</span>
<span class="n">parent_regs</span><span class="p">.</span><span class="n">eax</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="n">calls_ptrace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">parent_pid</span><span class="p">,</span> <span class="n">PTRACE_SETREGS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">parent_regs</span><span class="p">);</span>
<span class="n">calls_ptrace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">parent_pid</span><span class="p">,</span> <span class="n">PTRACE_DETACH</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">sub_80540CB</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div><p>Then, if the third argument is tested to be 32, and if that&rsquo;s not the case, <em>child1</em> will return <code>-1</code> in <code>eax</code>, detach from the <em>parent,</em> and will call <code>sub_80540CB</code> that&rsquo;ll simply exit. These are the arguments we get from <code>child1_main</code>:</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">equal_bytes_count</span> <span class="o">=</span> <span class="n">zero</span><span class="p">(</span><span class="mh">0xA4F57126</span><span class="p">,</span> <span class="n">input_buffer</span><span class="p">,</span> <span class="n">equal_bytes_count</span><span class="p">);</span>
</code></pre></div><p>So the third argument is the number of bytes equal between our decrypted input and the desired bytes we saw in <code>0x81A5100</code>. This is basically a test to see whether the second part of the flag was indeed correct. While we&rsquo;re at it, we&rsquo;ll also rename the second argument of our shellcode to <code>input_buffer</code>. Now that that&rsquo;s out of our way, time to get into the main logic of the third stage. But before that, when you get code dynamically generated while you&rsquo;re debugging, it&rsquo;s always a good idea to take a memory snapshot in IDA so you&rsquo;ll have this stored in your <em>idb</em> statically. Simply going to <em>Debugger→Take memory snapshot</em> will do, just make sure the segment you&rsquo;re new code is at is included.</p>
<p>Now, we can use <em>FindCrypt</em> again to see if we got some new crypto constants here in this new piece of code, so we&rsquo;ll <code>Ctrl+Alt+F</code>:</p>
<a class="lightgallery" href="/posts/flare-on-7-break/images/image_16.png" title="/posts/flare-on-7-break/images/image_16.png" data-thumbnail="/posts/flare-on-7-break/images/image_16.png">
        <img
            class="lazyload"
            src="/svg/loading.min.svg"
            data-src="images/image_16.png"
            data-srcset="/posts/flare-on-7-break/images/image_16.png, images/image_16.png 1.5x, /posts/flare-on-7-break/images/image_16.png 2x"
            data-sizes="auto"
            alt="/posts/flare-on-7-break/images/image_16.png" />
    </a>
<p>Indeed we get 3 hits, that identify data as <code>Big_Numbers3</code>. If we take a look at the YARA rule that triggers this, we can see that it&rsquo;s simply a string of a 64-byte number. We&rsquo;ll keep that in mind.</p>
<div class="highlight"><pre class="chroma"><code class="language-yaml" data-lang="yaml"><span class="l">rule Big_Numbers3</span><span class="w">
</span><span class="w"></span>{<span class="w">
</span><span class="w">	</span><span class="nt">meta</span><span class="p">:</span><span class="w">
</span><span class="w">		</span><span class="l">author = &#34;_pusher_&#34;</span><span class="w">
</span><span class="w">		</span><span class="l">description = &#34;Looks for big numbers 64:sized&#34;</span><span class="w">
</span><span class="w">		</span><span class="l">date = &#34;2016-07&#34;</span><span class="w">
</span><span class="w">	</span><span class="nt">strings</span><span class="p">:</span><span class="w">
</span><span class="w">        	</span><span class="l">$c0 = /[0-9a-fA-F]{64}/ fullword wide ascii</span><span class="w">
</span><span class="w">	</span><span class="nt">condition</span><span class="p">:</span><span class="w">
</span><span class="w">		</span><span class="l">$c0</span><span class="w">
</span><span class="w"></span>}<span class="w">
</span></code></pre></div><p>Quickly browsing around the functions that are called in <code>shellcode_main</code>, we see a few things that will help us later:</p>
<ol>
<li><code>sub_805409F</code> is a wrapper function that moves around the arguments and just calls <code>open</code></li>
<li><code>sub_80540B5</code> does the same for <code>read</code></li>
<li><code>sub_8054091</code> is just a <code>close</code> wrapper</li>
<li><code>sub_8054C75</code> looks a lot like a function we already analyzed - <code>copy_to_pid</code> which uses <code>ptrace</code> to copy bytes to the process specified.</li>
<li>There are a few functions that get the base of our shellcode + an offset. This is usually a method that shellcode writers use to hold strings. We&rsquo;ll examine the contents of those offsets and write a comment in the appropriate locations.</li>
</ol>
<p>Needles to say, we&rsquo;ll rename these functions accordingly for easier analysis. Let&rsquo;s have a high-level view of the code we have now:</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="kr">__cdecl</span> <span class="n">__noreturn</span> <span class="nf">shellcode_main</span><span class="p">(</span><span class="kt">int</span> <span class="n">a1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">input_buffer</span><span class="p">,</span> <span class="kt">int</span> <span class="n">equal_bytes_count</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">shellcode_base</span> <span class="o">=</span> <span class="mh">0x8053B70</span><span class="p">;</span>
  <span class="n">parent_pid</span> <span class="o">=</span> <span class="o">::</span><span class="n">parent_pid</span><span class="p">;</span>
  <span class="n">calls_ptrace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">::</span><span class="n">parent_pid</span><span class="p">,</span> <span class="n">PTRACE_GETREGS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">parent_regs</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span> <span class="n">equal_bytes_count</span> <span class="o">!=</span> <span class="mi">32</span> <span class="p">)</span>
  <span class="p">{</span>
    <span class="n">parent_regs</span><span class="p">.</span><span class="n">eax</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="n">calls_ptrace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">parent_pid</span><span class="p">,</span> <span class="n">PTRACE_SETREGS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">parent_regs</span><span class="p">);</span>
    <span class="n">calls_ptrace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">parent_pid</span><span class="p">,</span> <span class="n">PTRACE_DETACH</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">calls_exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="n">sub_80544E2</span><span class="p">(</span><span class="n">v12</span><span class="p">);</span>
  <span class="n">sub_80544E2</span><span class="p">(</span><span class="n">v15</span><span class="p">);</span>
  <span class="n">sub_80544E2</span><span class="p">(</span><span class="n">v11</span><span class="p">);</span>
  <span class="n">sub_8054447</span><span class="p">(</span><span class="n">v7</span><span class="p">,</span> <span class="n">shellcode_base</span> <span class="o">+</span> <span class="mh">0x12A6</span><span class="p">,</span> <span class="mi">64</span><span class="p">);</span> <span class="c1">// d1cc3447d5a9e1e6adae92faaea8770db1fab16b1568ea13c3715f2aeba9d84f
</span><span class="c1"></span>  <span class="n">sub_8054447</span><span class="p">(</span><span class="n">v8</span><span class="p">,</span> <span class="n">shellcode_base</span> <span class="o">+</span> <span class="mh">0x1224</span><span class="p">,</span> <span class="mi">64</span><span class="p">);</span> <span class="c1">// c10357c7a53fa2f1ef4a5bf03a2d156039e7a57143000c8d8f45985aea41dd31
</span><span class="c1"></span>  <span class="n">sub_8054447</span><span class="p">(</span><span class="n">v5</span><span class="p">,</span> <span class="n">shellcode_base</span> <span class="o">+</span> <span class="mh">0x11E3</span><span class="p">,</span> <span class="mi">64</span><span class="p">);</span> <span class="c1">// 480022d87d1823880d9e4ef56090b54001d343720dd77cbc5bc5692be948236c
</span><span class="c1"></span>  <span class="n">sub_8054447</span><span class="p">(</span><span class="n">v10</span><span class="p">,</span> <span class="n">shellcode_base</span> <span class="o">+</span> <span class="mh">0x11E3</span><span class="p">,</span> <span class="mi">64</span><span class="p">);</span><span class="c1">// 480022d87d1823880d9e4ef56090b54001d343720dd77cbc5bc5692be948236c
</span><span class="c1"></span>  <span class="n">sub_8054447</span><span class="p">(</span><span class="n">v6</span><span class="p">,</span> <span class="n">shellcode_base</span> <span class="o">+</span> <span class="mh">0x1265</span><span class="p">,</span> <span class="mi">64</span><span class="p">);</span> <span class="c1">// d036c5d4e7eda23afceffbad4e087a48762840ebb18e3d51e4146f48c04697eb
</span><span class="c1"></span>  <span class="n">qmemcpy</span><span class="p">(</span><span class="n">v12</span><span class="p">,</span> <span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="p">)(</span><span class="n">input_buffer</span> <span class="o">+</span> <span class="mi">48</span><span class="p">),</span> <span class="mh">0x18u</span><span class="p">);</span>
  <span class="n">v3</span> <span class="o">=</span> <span class="n">calls_open</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)(</span><span class="n">shellcode_base</span> <span class="o">+</span> <span class="mh">0x11D6</span><span class="p">));</span><span class="c1">// /dev/urandom
</span><span class="c1"></span>  <span class="n">calls_read</span><span class="p">(</span><span class="mh">0x20u</span><span class="p">,</span> <span class="n">v15</span><span class="p">,</span> <span class="n">v3</span><span class="p">);</span>
  <span class="n">sub_80543CA</span><span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="n">v15</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">v7</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">v16</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">v9</span><span class="p">);</span>
  <span class="n">calls_close</span><span class="p">(</span><span class="n">v3</span><span class="p">);</span>
  <span class="n">sub_805422A</span><span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="n">v15</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">v9</span><span class="p">);</span>
  <span class="n">sub_8054533</span><span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="n">v8</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">v15</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">v7</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">v11</span><span class="p">);</span>
  <span class="n">sub_805422A</span><span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="n">v15</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">v9</span><span class="p">);</span>
  <span class="n">sub_8054533</span><span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="n">v10</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">v15</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">v7</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">v13</span><span class="p">);</span>
  <span class="n">sub_80546E1</span><span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="n">v12</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">v11</span><span class="p">,</span> <span class="n">v15</span><span class="p">);</span>
  <span class="n">sub_80543CA</span><span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="n">v15</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">v7</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">v16</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">v14</span><span class="p">);</span>
  <span class="n">memset</span><span class="p">(</span><span class="n">v17</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">v17</span><span class="p">));</span>
  <span class="n">sub_8054882</span><span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="n">v13</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">v17</span><span class="p">,</span> <span class="mi">1024</span><span class="p">);</span>
  <span class="n">memset</span><span class="p">(</span><span class="n">v17</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">v17</span><span class="p">));</span>
  <span class="n">sub_8054882</span><span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="n">v14</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">v17</span><span class="p">,</span> <span class="mi">1024</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="n">sub_8054251</span><span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="n">v5</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">v13</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">sub_8054251</span><span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="n">v6</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">v14</span><span class="p">)</span> <span class="p">)</span>
  <span class="p">{</span>
    <span class="o">*</span><span class="p">(</span><span class="n">_BYTE</span> <span class="o">*</span><span class="p">)(</span><span class="n">input_buffer</span> <span class="o">+</span> <span class="mh">0x48</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">copy_to_pid_0</span><span class="p">(</span><span class="n">parent_pid</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">dword_81A57C0</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">**</span><span class="p">)</span><span class="n">input_buffer</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">&amp;</span><span class="n">shellcode_base</span><span class="p">,</span> <span class="mh">0x49</span><span class="p">);</span>
    <span class="n">parent_regs</span><span class="p">.</span><span class="n">eax</span> <span class="o">=</span> <span class="mi">32</span><span class="p">;</span>
    <span class="n">calls_ptrace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">parent_pid</span><span class="p">,</span> <span class="n">PTRACE_SETREGS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">parent_regs</span><span class="p">);</span>
    <span class="n">calls_ptrace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">parent_pid</span><span class="p">,</span> <span class="n">PTRACE_DETACH</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">calls_exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="n">parent_regs</span><span class="p">.</span><span class="n">eax</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="n">calls_ptrace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">parent_pid</span><span class="p">,</span> <span class="n">PTRACE_SETREGS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">parent_regs</span><span class="p">);</span>
  <span class="n">calls_ptrace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">parent_pid</span><span class="p">,</span> <span class="n">PTRACE_DETACH</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="n">calls_exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><ol>
<li>First, we have is the test to see whether the previous part of the flag was correct. We already passed that.</li>
<li>Then we have a few functions that get the BigNumber strings we saw, alongside a local variable and <code>64</code> which is probably the size in bytes.</li>
<li>Later, the code seems to read from <code>/dev/urandom</code>, and have quite a few function calls that seem to modify the local variables.</li>
<li>Finally, we have an if statement, which seems to operate on our local variables. If the condition is met, then we return 32 (which is what the <em>parent</em> expects as the success value, and we exit. If the condition is not met, then we return <code>-1</code> and exit. Looks like we need this condition to be met.</li>
</ol>
<p>Taking a look at the function in the condition - <code>sub_8054251</code>, it looks like it compares the two arguments it gets, and this makes sense.</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">int</span> <span class="n">__usercall</span> <span class="n">sub_8054251</span><span class="err">@</span><span class="o">&lt;</span><span class="n">eax</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_DWORD</span> <span class="o">*</span><span class="n">a1</span><span class="err">@</span><span class="o">&lt;</span><span class="n">eax</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">_DWORD</span> <span class="o">*</span><span class="n">a2</span><span class="err">@</span><span class="o">&lt;</span><span class="n">edx</span><span class="o">&gt;</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">v2</span> <span class="o">=</span> <span class="mi">32</span><span class="p">;</span>
  <span class="k">while</span> <span class="p">(</span> <span class="mi">1</span> <span class="p">)</span>
  <span class="p">{</span>
    <span class="o">--</span><span class="n">v2</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">a1</span><span class="p">[</span><span class="n">v2</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">a2</span><span class="p">[</span><span class="n">v2</span><span class="p">]</span> <span class="p">)</span>
      <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">a1</span><span class="p">[</span><span class="n">v2</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">a2</span><span class="p">[</span><span class="n">v2</span><span class="p">]</span> <span class="p">)</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="n">v2</span> <span class="p">)</span>
      <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>We have our input affect some of the local variables and the result of this modification is then compared with a fixed value.</p>
<p>Another function that looks worthy of understanding is <code>sub_8054447</code>. It gets a local variable, a pointer to a big number string, and a size of 64.</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">_DWORD</span> <span class="o">*</span><span class="n">__usercall</span> <span class="n">sub_8054447</span><span class="err">@</span><span class="o">&lt;</span><span class="n">eax</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_DWORD</span> <span class="o">*</span><span class="n">a1</span><span class="err">@</span><span class="o">&lt;</span><span class="n">eax</span><span class="o">&gt;</span><span class="p">,</span> <span class="kt">int</span> <span class="n">a2</span><span class="err">@</span><span class="o">&lt;</span><span class="n">edx</span><span class="o">&gt;</span><span class="p">,</span> <span class="kt">int</span> <span class="n">a3</span><span class="err">@</span><span class="o">&lt;</span><span class="n">ecx</span><span class="o">&gt;</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">result</span> <span class="o">=</span> <span class="n">sub_80544E2</span><span class="p">(</span><span class="n">a1</span><span class="p">);</span>
  <span class="n">v5</span> <span class="o">=</span> <span class="n">a3</span> <span class="o">-</span> <span class="mi">8</span><span class="p">;</span>
  <span class="n">v6</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">while</span> <span class="p">(</span> <span class="n">v5</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="p">)</span>
  <span class="p">{</span>
    <span class="n">v7</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kr">__int8</span> <span class="o">*</span><span class="p">)(</span><span class="n">v5</span> <span class="o">+</span> <span class="n">a2</span><span class="p">);</span>
    <span class="n">v8</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span> <span class="p">)</span>
    <span class="p">{</span>
      <span class="n">v10</span> <span class="o">=</span> <span class="n">v7</span><span class="o">++</span><span class="p">;</span>
      <span class="n">v11</span> <span class="o">=</span> <span class="o">*</span><span class="n">v10</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span> <span class="n">v11</span> <span class="o">&gt;=</span> <span class="sc">&#39;0&#39;</span> <span class="o">&amp;&amp;</span> <span class="n">v11</span> <span class="o">&lt;=</span> <span class="sc">&#39;9&#39;</span> <span class="p">)</span>
      <span class="p">{</span>
        <span class="n">v11</span> <span class="o">-=</span> <span class="sc">&#39;0&#39;</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span> <span class="n">v11</span> <span class="o">&gt;=</span> <span class="sc">&#39;a&#39;</span> <span class="o">&amp;&amp;</span> <span class="n">v11</span> <span class="o">&lt;=</span> <span class="sc">&#39;f&#39;</span> <span class="p">)</span>
      <span class="p">{</span>
        <span class="n">v11</span> <span class="o">=</span> <span class="n">v11</span> <span class="o">-</span> <span class="sc">&#39;a&#39;</span> <span class="o">+</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span> <span class="n">v11</span> <span class="o">&gt;=</span> <span class="sc">&#39;A&#39;</span> <span class="o">&amp;&amp;</span> <span class="n">v11</span> <span class="o">&lt;=</span> <span class="sc">&#39;F&#39;</span> <span class="p">)</span>
      <span class="p">{</span>
        <span class="n">v11</span> <span class="o">=</span> <span class="n">v11</span> <span class="o">-</span> <span class="sc">&#39;A&#39;</span> <span class="o">+</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="n">v8</span> <span class="o">=</span> <span class="n">v11</span> <span class="o">&amp;</span> <span class="mh">0xF</span> <span class="o">|</span> <span class="p">(</span><span class="mi">16</span> <span class="o">*</span> <span class="n">v8</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">result</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">a1</span><span class="p">[</span><span class="n">v6</span><span class="p">];</span>
    <span class="o">*</span><span class="n">result</span> <span class="o">=</span> <span class="n">v8</span><span class="p">;</span>
    <span class="n">v5</span> <span class="o">-=</span> <span class="mi">8</span><span class="p">;</span>
    <span class="o">++</span><span class="n">v6</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>It first calls <code>sub_80544E2</code> which seems to just zero the memory at the local variable and then seems to decode the hex string it got in the second argument. This simply looks like a function that gets a big number string and then converts it into an actual big number in memory.</p>
<p>This is one crucial point where experienced reverse engineers differentiate themselves from inexperienced ones. The most obvious way to tackle this problem at hand is to simply reverse engineer every function we see here that modifies our local variables, understand the logic behind it, and finally write an algorithm that will reverse this process and will get us the rest of the flag from the desired result. This is what inexperienced reversers will probably do; it totally works and there&rsquo;s no shame with that. Having said that, there is a more efficient way to do this. Experienced reversers may look at this code and say &ldquo;Huh, looks like we have quite a few functions that handle this unique data type, we&rsquo;re on the final stretch of this challenge, and we already know this data type (big numbers); there is an option that our dear challenge author didn&rsquo;t write this code from scratch, but perhaps they used some library / open-source code&rdquo;. With this assumption in mind, they may do the following:</p>
<a class="lightgallery" href="/posts/flare-on-7-break/images/image_17.png" title="/posts/flare-on-7-break/images/image_17.png" data-thumbnail="/posts/flare-on-7-break/images/image_17.png">
        <img
            class="lazyload"
            src="/svg/loading.min.svg"
            data-src="images/image_17.png"
            data-srcset="/posts/flare-on-7-break/images/image_17.png, images/image_17.png 1.5x, /posts/flare-on-7-break/images/image_17.png 2x"
            data-sizes="auto"
            alt="/posts/flare-on-7-break/images/image_17.png" />
    </a>
<p>The first result written in C seems interesting. Scrolling around the code, <a href="https://github.com/kokke/tiny-bignum-c/blob/master/bn.c#L98" target="_blank" rel="noopener noreffer">this</a> function seems like it could potentially be the source version of the code we saw in <code>sub_8054447</code>. In order to understand whether this is the library that has been used here, we need to try and match functions from our challenge to functions in <em>tiny-bignum-c</em>.
Let&rsquo;s look at <code>sub_80544E2</code> for example (which is called from the function that converts a string to a big number):</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">_DWORD</span> <span class="o">*</span><span class="n">__usercall</span> <span class="n">sub_80544E2</span><span class="err">@</span><span class="o">&lt;</span><span class="n">eax</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_DWORD</span> <span class="o">*</span><span class="n">result</span><span class="err">@</span><span class="o">&lt;</span><span class="n">eax</span><span class="o">&gt;</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">v1</span> <span class="o">=</span> <span class="n">result</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">32</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span> <span class="p">)</span>
  <span class="p">{</span>
    <span class="n">result</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">v1</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="o">*</span><span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>Looks like this <a href="https://github.com/kokke/tiny-bignum-c/blob/1d7a1f9b8e77316187a6b3eae8e68d60a6f9a4d4/bn.c#L37" target="_blank" rel="noopener noreffer">function</a> from <em>tiny-bignum-c</em>:</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="nf">bignum_init</span><span class="p">(</span><span class="k">struct</span> <span class="nc">bn</span><span class="o">*</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">require</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="s">&#34;n is null&#34;</span><span class="p">);</span>

  <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">BN_ARRAY_SIZE</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">n</span><span class="o">-&gt;</span><span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>Seems to be like this is the library the author used. What we need to do now is to go over the functions called in <code>shellcode_main</code> and match them to this <em>tiny-bignum-c</em> project functions. A few comparisons and function renaming later, we get the following code:</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">bignum_init</span><span class="p">(</span><span class="n">input_bignum</span><span class="p">);</span>
<span class="n">bignum_init</span><span class="p">(</span><span class="n">bignum_random</span><span class="p">);</span>
<span class="n">bignum_init</span><span class="p">(</span><span class="n">v11</span><span class="p">);</span>
<span class="n">bignum_from_string</span><span class="p">(</span><span class="n">bignum_1</span><span class="p">,</span> <span class="n">shellcode_base</span> <span class="o">+</span> <span class="mh">0x12A6</span><span class="p">,</span> <span class="mi">64</span><span class="p">);</span><span class="c1">// d1cc3447d5a9e1e6adae92faaea8770db1fab16b1568ea13c3715f2aeba9d84f
</span><span class="c1"></span><span class="n">bignum_from_string</span><span class="p">(</span><span class="n">bignum_2</span><span class="p">,</span> <span class="n">shellcode_base</span> <span class="o">+</span> <span class="mh">0x1224</span><span class="p">,</span> <span class="mi">64</span><span class="p">);</span><span class="c1">// c10357c7a53fa2f1ef4a5bf03a2d156039e7a57143000c8d8f45985aea41dd31
</span><span class="c1"></span><span class="n">bignum_from_string</span><span class="p">(</span><span class="n">bignum_3</span><span class="p">,</span> <span class="n">shellcode_base</span> <span class="o">+</span> <span class="mh">0x11E3</span><span class="p">,</span> <span class="mi">64</span><span class="p">);</span><span class="c1">// 480022d87d1823880d9e4ef56090b54001d343720dd77cbc5bc5692be948236c
</span><span class="c1"></span><span class="n">bignum_from_string</span><span class="p">(</span><span class="n">bignum_3_copy</span><span class="p">,</span> <span class="n">shellcode_base</span> <span class="o">+</span> <span class="mh">0x11E3</span><span class="p">,</span> <span class="mi">64</span><span class="p">);</span><span class="c1">// 480022d87d1823880d9e4ef56090b54001d343720dd77cbc5bc5692be948236c
</span><span class="c1"></span><span class="n">bignum_from_string</span><span class="p">(</span><span class="n">bignum_4</span><span class="p">,</span> <span class="n">shellcode_base</span> <span class="o">+</span> <span class="mh">0x1265</span><span class="p">,</span> <span class="mi">64</span><span class="p">);</span><span class="c1">// d036c5d4e7eda23afceffbad4e087a48762840ebb18e3d51e4146f48c04697eb
</span><span class="c1"></span><span class="n">qmemcpy</span><span class="p">(</span><span class="n">input_bignum</span><span class="p">,</span> <span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="p">)(</span><span class="n">input_buffer</span> <span class="o">+</span> <span class="mi">48</span><span class="p">),</span> <span class="mh">0x18u</span><span class="p">);</span>
<span class="n">file_urandom</span> <span class="o">=</span> <span class="n">calls_open</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)(</span><span class="n">shellcode_base</span> <span class="o">+</span> <span class="mh">0x11D6</span><span class="p">));</span><span class="c1">// /dev/urandom
</span><span class="c1"></span><span class="n">calls_read</span><span class="p">(</span><span class="mh">0x20u</span><span class="p">,</span> <span class="n">bignum_random</span><span class="p">,</span> <span class="n">file_urandom</span><span class="p">);</span>
<span class="n">bignum_divmod</span><span class="p">(</span><span class="n">bignum_random</span><span class="p">,</span> <span class="n">bignum_1</span><span class="p">,</span> <span class="n">v16</span><span class="p">,</span> <span class="n">v9</span><span class="p">);</span>
<span class="n">calls_close</span><span class="p">(</span><span class="n">file_urandom</span><span class="p">);</span>
<span class="n">bignum_assign</span><span class="p">(</span><span class="n">bignum_random</span><span class="p">,</span> <span class="n">v9</span><span class="p">);</span>
<span class="n">sub_8054533</span><span class="p">(</span><span class="n">bignum_2</span><span class="p">,</span> <span class="n">bignum_random</span><span class="p">,</span> <span class="n">bignum_1</span><span class="p">,</span> <span class="n">v11</span><span class="p">);</span>
<span class="n">bignum_assign</span><span class="p">(</span><span class="n">bignum_random</span><span class="p">,</span> <span class="n">v9</span><span class="p">);</span>
<span class="n">sub_8054533</span><span class="p">(</span><span class="n">bignum_3_copy</span><span class="p">,</span> <span class="n">bignum_random</span><span class="p">,</span> <span class="n">bignum_1</span><span class="p">,</span> <span class="n">bignum_result_1</span><span class="p">);</span>
<span class="n">bignum_mul</span><span class="p">(</span><span class="n">input_bignum</span><span class="p">,</span> <span class="n">v11</span><span class="p">,</span> <span class="n">bignum_random</span><span class="p">);</span>
<span class="n">bignum_divmod</span><span class="p">(</span><span class="n">bignum_random</span><span class="p">,</span> <span class="n">bignum_1</span><span class="p">,</span> <span class="n">v16</span><span class="p">,</span> <span class="n">bignum_result_2</span><span class="p">);</span>
<span class="n">memset</span><span class="p">(</span><span class="n">v17</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">v17</span><span class="p">));</span>
<span class="n">bignum_to_string</span><span class="p">(</span><span class="n">bignum_result_1</span><span class="p">,</span> <span class="n">v17</span><span class="p">,</span> <span class="p">(</span><span class="n">_DWORD</span> <span class="o">*</span><span class="p">)</span><span class="mh">0x400</span><span class="p">);</span>
<span class="n">memset</span><span class="p">(</span><span class="n">v17</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">v17</span><span class="p">));</span>
<span class="n">bignum_to_string</span><span class="p">(</span><span class="n">bignum_result_2</span><span class="p">,</span> <span class="n">v17</span><span class="p">,</span> <span class="p">(</span><span class="n">_DWORD</span> <span class="o">*</span><span class="p">)</span><span class="mh">0x400</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="n">bignum_cmp</span><span class="p">(</span><span class="n">bignum_3</span><span class="p">,</span> <span class="n">bignum_result_1</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">bignum_cmp</span><span class="p">(</span><span class="n">bignum_4</span><span class="p">,</span> <span class="n">bignum_result_2</span><span class="p">)</span> <span class="p">)</span>
<span class="p">{</span>
  <span class="o">*</span><span class="p">(</span><span class="n">_BYTE</span> <span class="o">*</span><span class="p">)(</span><span class="n">input_buffer</span> <span class="o">+</span> <span class="mh">0x48</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">copy_to_pid_0</span><span class="p">(</span><span class="n">parent_pid</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">dword_81A57C0</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">**</span><span class="p">)</span><span class="n">input_buffer</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">&amp;</span><span class="n">shellcode_base</span><span class="p">,</span> <span class="mh">0x49</span><span class="p">);</span>
  <span class="n">parent_regs</span><span class="p">.</span><span class="n">eax</span> <span class="o">=</span> <span class="mi">32</span><span class="p">;</span>
  <span class="n">calls_ptrace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">parent_pid</span><span class="p">,</span> <span class="n">PTRACE_SETREGS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">parent_regs</span><span class="p">);</span>
  <span class="n">calls_ptrace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">parent_pid</span><span class="p">,</span> <span class="n">PTRACE_DETACH</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="n">calls_exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>Unfortunately, we couldn&rsquo;t find a match for <code>sub_8054533</code>. In addition, looks like the challenge uses 64 bytes of random data from <code>/dev/urandom</code>. This doesn&rsquo;t make much sense since the calculation needs to be consistent across executions, since there should be one flag for all of them. We&rsquo;ll keep those two facts in mind while analyzing the rest of the code.</p>
<h3 id="reversing-the-process">Reversing the Process</h3>
<p>After debugging this process we can notice a few facts:</p>
<ul>
<li>
<p>The first comparison <code>bignum_cmp(bignum_3, bignum_result_1)</code> always returns true, so we&rsquo;ll only have to worry about the second one.</p>
</li>
<li>
<p><code>sub_8054533</code> doesn&rsquo;t seem do to something that&rsquo;s relevant for us, only assigning the first bignum argument to the fourth bignum argument.</p>
</li>
<li>
<p>The random bytes don&rsquo;t affect the result, since their being overwritten with another bignum:</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">sub_8054533</span><span class="p">(</span><span class="n">bignum_2</span><span class="p">,</span> <span class="n">bignum_random</span><span class="p">,</span> <span class="n">bignum_1</span><span class="p">,</span> <span class="n">v11</span><span class="p">);</span> <span class="c1">// v1 = bignum2
</span><span class="c1"></span><span class="n">bignum_mul</span><span class="p">(</span><span class="n">input_bignum</span><span class="p">,</span> <span class="n">v11</span><span class="p">,</span> <span class="n">bignum_random</span><span class="p">);</span>
</code></pre></div></li>
<li>
<p>From the <em>tiny-bignum-c</em> <a href="https://github.com/kokke/tiny-bignum-c/blob/master/bn.c#L394" target="_blank" rel="noopener noreffer">source code</a>, we learn that <code>bignum_divmod(a, b, c, d)</code> puts <code>a%b</code> in <code>d</code> and <code>a/b</code> in <code>c</code></p>
</li>
</ul>
<p>Now we&rsquo;ll focus on the second check, which is affected by the rest of our flag. The first thing we already know is that the result of the whole process stored in <code>bignum_result_2</code> should be equal <code>bignum4</code> (<code>0xd036c5d4e7eda23afceffbad4e087a48762840ebb18e3d51e4146f48c04697eb</code>). Our input is copied into <code>input_bignum</code> and the process starts. Here are the stages:</p>
<ol>
<li>
<p>Our input is multiplied with <code>v11</code> which contains the same value as <code>bignum2</code> as we already saw. The result is inserted into <code>bignum_random</code></p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">bignum_mul</span><span class="p">(</span><span class="n">input_bignum</span><span class="p">,</span> <span class="n">v11</span><span class="p">,</span> <span class="n">bignum_random</span><span class="p">);</span>
</code></pre></div></li>
<li>
<p><code>bignum_result_2</code> is a divmod result of <code>bignum_random</code> and <code>bignum_1</code></p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">bignum_divmod</span><span class="p">(</span><span class="n">bignum_random</span><span class="p">,</span> <span class="n">bignum_1</span><span class="p">,</span> <span class="n">v16</span><span class="p">,</span> <span class="n">bignum_result_2</span><span class="p">);</span>
</code></pre></div></li>
<li>
<p>Finally, <code>bignum_result_2</code> is compared to <code>bignum4</code></p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="n">bignum_cmp</span><span class="p">(</span><span class="n">bignum_3</span><span class="p">,</span> <span class="n">bignum_result_1</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">bignum_cmp</span><span class="p">(</span><span class="n">bignum_4</span><span class="p">,</span> <span class="n">bignum_result_2</span><span class="p">)</span> <span class="p">)</span>
</code></pre></div></li>
</ol>
<p>So essentially the equation looks like this:</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="p">(</span><span class="n">input_bignum</span> <span class="o">*</span> <span class="n">bignum2</span><span class="p">)</span> <span class="o">%</span> <span class="n">bignum1</span> <span class="o">=</span> <span class="n">bignum4</span>
</code></pre></div><p>We&rsquo;ll use Python (&gt;3.8) to reverse this and get the <code>input_bignum</code>, after that we&rsquo;ll convert this to ascii:</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">bignum4</span> <span class="o">=</span> <span class="mh">0xd036c5d4e7eda23afceffbad4e087a48762840ebb18e3d51e4146f48c04697eb</span>
<span class="n">bignum2</span> <span class="o">=</span> <span class="mh">0xc10357c7a53fa2f1ef4a5bf03a2d156039e7a57143000c8d8f45985aea41dd31</span>
<span class="n">bignum1</span> <span class="o">=</span> <span class="mh">0xd1cc3447d5a9e1e6adae92faaea8770db1fab16b1568ea13c3715f2aeba9d84f</span>

<span class="k">print</span><span class="p">(</span><span class="n">unhex</span><span class="p">(</span><span class="n">format</span><span class="p">(</span><span class="n">bignum4</span> <span class="o">*</span> <span class="nb">pow</span><span class="p">(</span><span class="n">bignum2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bignum1</span> <span class="p">)</span> <span class="o">%</span> <span class="n">bignum1</span> <span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">))[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

<span class="c1"># Results:</span>
<span class="c1"># b&#39;_n0_puppi3s@flare-on.com&#39;</span>
</code></pre></div><p>Hooray! Putting all the parts together we get the flag - <code>w3lc0mE_t0_Th3_l4nD_0f_De4th_4nd_d3strUct1oN_4nd_n0_puppi3s@flare-on.com</code>.</p>
<p>Inserting this to the challenge finally yields the winning message:</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ ./break
welcome to the land of sunshine and rainbows!
as a reward <span class="k">for</span> getting this far in FLARE-ON, we<span class="err">&#39;</span>ve decided to make this one soooper easy

please enter a password friend :<span class="o">)</span> w3lc0mE_t0_Th3_l4nD_0f_De4th_4nd_d3strUct1oN_4nd_n0_puppi3s@flare-on.com

hooray! the flag is: w3lc0mE_t0_Th3_l4nD_0f_De4th_4nd_d3strUct1oN_4nd_n0_puppi3s@flare-on.com
</code></pre></div><h1 id="summary">Summary</h1>
<p>This challenge contained quite a lot of learning opportunities and required thinking outside the box. This was probably one of the best challenges we&rsquo;ve had the pleasure of solving — ever. We tried to show different approaches that you might find useful in future challenges. We hope that you learned from this writeup and enjoy reading it as much as we enjoyed writing it.</p>
<hr>
<h1 id="appendix">Appendix</h1>
<ol>
<li>
<p>String decryption script</p>
<p><a href="/posts/flare-on-7-break/decrypt_strings.py" rel="">decrypt_strings.py</a></p>
</li>
</ol>
</div><div class="post-footer" id="post-footer">
    <div class="post-info">
        <div class="post-info-line">
            <div class="post-info-mod">
                <span>Updated on 2020-10-23</span>
            </div>
            <div class="post-info-license"></div>
        </div>
        <div class="post-info-line">
            <div class="post-info-md"></div>
            <div class="post-info-share">
                <span></span>
            </div>
        </div>
    </div>

    <div class="post-info-more">
        <section class="post-tags"><i class="fas fa-tags fa-fw"></i>&nbsp;<a href="/tags/flare-on/">flare-on</a></section>
        <section>
            <span><a href="javascript:void(0);" onclick="window.history.back();">Back</a></span>&nbsp;|&nbsp;<span><a href="/">Home</a></span>
        </section>
    </div>

    <div class="post-nav"><a href="/posts/flare-on7-crackinstaller/" class="prev" rel="prev" title="Flare-On 7 — 09 crackinstaller"><i class="fas fa-angle-left fa-fw"></i>Flare-On 7 — 09 crackinstaller</a>
            <a href="/posts/flare-on-7-rabbithole/" class="next" rel="next" title="Flare-On 7 — 11 Rabbithole">Flare-On 7 — 11 Rabbithole<i class="fas fa-angle-right fa-fw"></i></a></div>
</div>
</article></div>
            </main><footer class="footer">
        <div class="footer-container"><div class="footer-line">Powered by <a href="https://gohugo.io/" target="_blank" rel="noopener noreffer" title="Hugo 0.76.5">Hugo</a> | Theme - <a href="https://github.com/dillonzq/LoveIt" target="_blank" rel="noopener noreffer" title="LoveIt 0.2.10"><i class="far fa-kiss-wink-heart fa-fw"></i> LoveIt</a>
                </div><div class="footer-line"><i class="far fa-copyright fa-fw"></i><span itemprop="copyrightYear">2020</span><span class="author" itemprop="copyrightHolder">&nbsp;<a href="/" target="_blank"></a></span></div>
        </div>
    </footer></div>

        <div id="fixed-buttons"><a href="#" id="back-to-top" class="fixed-button" title="Back to Top">
                <i class="fas fa-arrow-up fa-fw"></i>
            </a><a href="#" id="view-comments" class="fixed-button" title="View Comments">
                <i class="fas fa-comment fa-fw"></i>
            </a>
        </div><link rel="stylesheet" href="/lib/lightgallery/lightgallery.min.css"><script type="text/javascript" src="/lib/smooth-scroll/smooth-scroll.min.js"></script><script type="text/javascript" src="/lib/lazysizes/lazysizes.min.js"></script><script type="text/javascript" src="/lib/lightgallery/lightgallery.min.js"></script><script type="text/javascript" src="/lib/lightgallery/lg-thumbnail.min.js"></script><script type="text/javascript" src="/lib/lightgallery/lg-zoom.min.js"></script><script type="text/javascript" src="/lib/clipboard/clipboard.min.js"></script><script type="text/javascript">window.config={"code":{"copyTitle":"Copy to clipboard","maxShownLines":60},"comment":{},"lightGallery":{"actualSize":false,"exThumbImage":"data-thumbnail","hideBarsDelay":2000,"selector":".lightgallery","speed":400,"thumbContHeight":80,"thumbWidth":80,"thumbnail":true}};</script><script type="text/javascript" src="/js/theme.min.js"></script><script type="text/javascript">
            window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments);}gtag('js', new Date());
            gtag('config', 'G-Z0NYXY577C');
        </script><script type="text/javascript" src="https://www.googletagmanager.com/gtag/js?id=G-Z0NYXY577C" async></script></body>
</html>
